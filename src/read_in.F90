module read_in_system

! Module for reading in and manipulating integral files which entirely define
! the Hamiltonian corresponding to a 'real' system.

use const

implicit none

contains

    subroutine read_in_integrals(sys, store_info, verbose)

        ! Read in a FCIDUMP file, which contains the kinetic and coulomb
        ! integrals, one-particle eigenvalues and other system information.
        ! File format (partially) defined in Comp. Phys. Commun. 54 (1989) 75.
        ! See also notes below.
        !
        ! In:
        !    store_info (optional): if true (default) then store the data read
        !        in.  Otherwise the basis defined by the FCIDUMP file is simply
        !        printed out.
        !    verbose (optional): print out information for each single-particle
        !         state.  Default: true.
        ! In/Out:
        !    sys: system to be studied.  The nel, nvirt, read_in%uhf, and
        !        read_in%Ecore components are set using information from the
        !        integral dump file.

        use const, only: int_64
        use basis, only: write_basis_fn, write_basis_fn_header, write_basis_fn_title
        use basis_types, only: basis_fn_t, dealloc_basis_fn_t_array
        use molecular_integrals
        use point_group_symmetry, only: init_pg_symmetry
        use read_in_symmetry, only: is_gamma_irrep_read_in
        use momentum_sym_read_in, only: init_read_in_momentum_symmetry
        use system, only: sys_t

        use checking, only: check_allocate, check_deallocate
        use errors, only: stop_all, warning
        use parallel
        use ranking, only: insertion_rank
        use utils, only: tri_ind_reorder, int_fmt

        use, intrinsic :: iso_fortran_env

        type(sys_t), intent(inout) :: sys
        logical, intent(in), optional :: store_info, verbose

        logical :: t_store, t_verbose
        logical :: momentum_sym

        ! System data
        ! We don't know how many orbitals we have until we read in the FCI
        ! namelist, so have to hardcode the array sizes.
        ! It's reasonably safe to assume that we'll never use more than 1000
        ! orbitals!
        integer :: norb, nelec, ms2,  isym, syml(1000), symlz(1000), nprop(3), propbitlen
        integer(int_64) :: orbsym(1000)
        ! all basis functions, including inactive ones.
        type(basis_fn_t), allocatable :: all_basis_fns(:)

        ! Integrals
        integer :: i, j, a, b, ii, jj, aa, bb, orbs(4), active(2), core(2), ia, ic, iorb
        integer(int_64) :: ti
        real(p) :: x, y, im_core
        complex(p) :: compint

        ! reading in...
        integer :: ir, ios, ierr
        logical :: t_exists
        integer :: active_basis_offset, rhf_fac
        integer, allocatable :: seen_ijij(:), seen_iaib(:,:), sp_eigv_rank(:), sp_fcidump_rank(:)
        logical, allocatable :: seen_iha(:)
        real(p), allocatable :: sp_eigv(:)
        logical :: uhf
        integer :: int_err, max_err_msg, iunit
        character(1024) :: err_msg

        namelist /FCI/ norb, nelec, ms2, orbsym, uhf, isym, syml, symlz, nprop, propbitlen

        iunit = 6

        ! avoid annoying compiler warnings over unused variables in FCI namelist
        ! that are present for NECI compatibility.
        isym = 0
        syml = 0
        symlz = 0
        ! Set namelist parameters to defaults that can't be confused for actual input.
        nelec = 0
        ms2 = huge(0)
        norb = 0
        uhf = .false.
        ! Set orbsym to be zero to ensure sensible behaviour if no symmetry
        ! information is provided in FCIDUMP.
        orbsym(:) = 0
        ! Set variables for translational symmetry to easily-detectable values.
        nprop = [-1, -1, -1]
        propbitlen = -1

        t_store = .true.
        if (present(store_info)) t_store = store_info
        t_verbose = .true.
        if (present(verbose)) t_verbose = verbose

        ! FCIDUMP file format is as follows:

        ! &FCI             ! FCI namelist.  See below.
        ! /                ! / terminates a namelist.  Most compilers also
        !                  ! implement the extension where &END is used to
        !                  ! terminate the namelist instead.
        ! x i a j b        ! x is a float, i, j, a and b are integers.

        ! &FCI namelist:
        !  * NORB: number of orbitals in the basis.  See note on basis indices below.
        !       Must be provided in FCIDUMP.
        !  * NELEC: number of electrons in system.
        !       Must be provided either in FCIDUMP or input file.
        !  * MS2: spin polarisation.
        !       Must be provided either in FCIDUMP or input file.
        !  * ORBSYM: array containing symmetry label of each orbital.  See
        !    symmetry notes below and in pg_symmetry/momentum_sym_read_in.
        !       If not provided in FCIDUMP assume no symmetry in system.
        !  * UHF: true if FCIDUMP file was produced from an unrestricted
        !    Hartree-Fock calculation.  See note on basis indices below.
        !       If not provided in FCIDUMP assumed to be an RHF calculation.
        !    NOTE:
        !         We assume that in UHF calculations the number of spin-up basis
        !         functions is equal to the number of spin-down basis functions.
        !  * ISYM: currently unused.  Defined solely for compatibility with NECI
        !    FCIDUMP files.  Gives the symmetry of the wavefunction formed by
        !    occupied the NELEC lowest energy spin-orbitals.
        !  * SYML: currently unused.  Defined solely for compatibility with NECI
        !    FCIDUMP files.  Array containing L (angular momentum) for each orbital.
        !    Set to -1 if L is not a good quantum number.
        !       If not provided in FCIDUMP assume no symmetry in system.
        !  * SYMLZ:  Array containing Lz (angular momentum along the z-axis) for each orbital.
        !    For example d_xz would have L=2 and Lz=1, and dyz L=2, Lz=-1.
        !  * NPROP: Dimensions of supercell used in translationally symmetric systems.
        !  * PROPBITLEN: Length in bits of each property in translationally symmetric
        !    systems.
        ! Integrals:
        !  * if i = j = a = b = 0, E_core = x , where E_core contains the
        !    nuclear-nuclear and other non-electron contributions to the
        !    Hamiltonian.
        !  * if a = j = b = 0, \epsilon_i = x, the single-particle eigenvalue
        !    of the i-th orbital.
        !  * if j = b = 0, < i | h | a > = x, the one-body Hamiltonian matrix element
        !    between the i-th and a-th orbitals, where h = T+V_ext.
        !  * otherwise < i j | 1/r_12 | a b > = x, the Coulomb integral between
        !    the i-a co-density and the j-b codensity.  Note the Coulomb
        !    integrals are given in Chemists' notation, a rare instance that
        !    Chemists are wrong and Physicists correct.

        ! Basis indices:
        ! RHF: All indices are in terms of spatial orbitals.  NORB is the
        ! number of spatial orbitals.
        ! UHF: All indices are in terms of spin orbitals.  NORB is the
        ! number of spin orbitals.
        ! Basis functions (as stored by basis_fns) are always stored as spin
        ! orbitals (the memory saving involved in storing only spatial orbitals
        ! is not worth the additional overhead/headache, as FCIQMC involves
        ! working in spin orbitals).  Integrals are expensive to store, so we
        ! store them in as compressed format as possible.

        ! Symmetry:
        ! Molecular orbitals are defined by the D2h point group (or a subgroup
        ! thereof)by the quantum chemistry packages (QChem, MOLPRO) used to
        ! produce FCIDUMP files , so we need only concern ourselves with Abelian
        ! symmetries.
        ! If ORBSYM(i) = 0, then the symmetry of the i-th orbital is not
        ! well-defined.  In this case, we can only resort to turning off all
        ! symmetry (i.e. set all orbitals to be totally symmetric).  Note that
        ! this has memory implications for the integral storage.
        ! ORBSYM(i) = S+1, where S is the symmetry label defining the
        ! irreducible representation spanned by the i-th orbital.
        ! See notes in pg_symmetry about the symmetry label for Abelian point
        ! groups.
        !
        ! For periodic systems basis symmetries are defined by their kpoint
        ! vector. This is converted into a single index within the space of
        ! allowed kpoints, and this index used during calculations.

        ! Only do i/o on root processor.
        if (parent) then
            inquire(file=sys%read_in%fcidump, exist=t_exists)
            if (.not.t_exists) call stop_all('read_in_integrals', 'FCIDUMP does not &
                                                               &exist:'//trim(sys%read_in%fcidump))
            open (newunit=ir, file=sys%read_in%fcidump, status='old', form='formatted')

            ! If FCIDUMP doesn't contain uhf data, can end up accessing uninitalised value for uhf.
            uhf = .false.
            ! read system data
            read (ir, FCI)
            sys%read_in%uhf = uhf
            if (norb == 0) call stop_all('read_in_integrals', &
                'norb not provided in FCIDUMP header.')
            if (norb > 1000) call stop_all('read_in_integrals', &
                'norb > 1000. Please increase hard-coded limits within read_in.F90!')
        end if

#ifdef PARALLEL
        ! Distribute FCI namelist.
        call MPI_BCast(norb, 1, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
        call MPI_BCast(nelec, 1, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
        call MPI_BCast(ms2, 1, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
        call MPI_BCast(orbsym, 1000, MPI_INTEGER8, root, MPI_COMM_WORLD, ierr)
        call MPI_BCast(isym, 1, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
        call MPI_BCast(sys%read_in%uhf, 1, MPI_LOGICAL, root, MPI_COMM_WORLD, ierr)
        call MPI_BCast(syml, 1000, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
        call MPI_BCast(symlz, 1000, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
        call MPI_BCast(propbitlen, 1, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
        call MPI_BCast(nprop, 3, MPI_INTEGER, root, MPI_COMM_WORLD, ierr)
#endif

        ! NOTE: nbasis is currently the number of spin-orbitals in the FCIDUMP file.
        ! This is changed to the number of spin-orbitals active the calculation
        ! later on.

        if (sys%read_in%uhf) then
            sys%basis%nbasis = norb
            rhf_fac = 1
        else
            sys%basis%nbasis = 2*norb
            rhf_fac = 2  ! need to double count some integrals.
        end if

        if (sys%nel == 0 .and. sys%Ms == huge(1)) then
            if (nelec == 0 .or. ms2 == huge(1)) then
                call stop_all('read_in_integrals', 'Nelec and ms not provided in FCIDUMP file or '&
                    &'input file. Please specify in one of these locations.')
            else
                if (parent) then
                    write (error_unit,'(1X,"WARNING: using the number of electrons in FCIDUMP file: '&
                        //trim(sys%read_in%fcidump)//'.")')
                    write (error_unit,'(1X,"FCIDUMP file indicates ",i0," electrons.")') nelec
                end if
                sys%nel = nelec
                sys%Ms = ms2
            end if
        else if (sys%Ms == huge(1) .and. parent) then
            call stop_all('read_in_integrals', 'Only provided nel not Ms in input file. Please '&
                &'either provide both nel and Ms or provide neither to use values from FCIDUMP')
        else if (sys%nel == 0 .and. parent) then
            call stop_all('read_in_integrals', 'Only provided Ms not nel in input file. Please '&
                &'either provide both nel and Ms or provide neither to use values from FCIDUMP')
        else if ((sys%nel /= nelec .or. sys%Ms /= ms2) .and. parent) then
            write (error_unit,'(1X,"WARNING: overriding the number of electrons in FCIDUMP file: '&
                              //trim(sys%read_in%fcidump)//'.")')
            write (error_unit,'(1X,"FCIDUMP file indicates ",i0," electrons.")') nelec
            write (error_unit,'(1X,"Input file set ",i0," electrons.",/)') sys%nel
        end if

        ! Sanity check
        if (any(sys%cas /= -1) .and. parent) then
            if (sys%cas(1) > sys%nel) then
                write (error_unit,'(1X,"Number of electrons in the system: ",i0,".")') sys%nel
                write (error_unit,'(1X,"Number of active electrons in CAS: ",i0,".")') sys%cas(1)
                call stop_all('read_in_integrals', 'CAS cannot have more active electrons than in the system.')
            end if
            if (sys%cas(2) > (sys%basis%nbasis-(sys%nel-sys%cas(1)))/2) then
                ! The maximum number of active spin orbitals is nbasis - # core orbitals.
                ! The number of core orbitals is nel-cas(1).
                ! CAS(2) is in terms of spatial orbitals.
                write (error_unit,'(1X,"Number of spin-orbitals: ",i0,".")') sys%basis%nbasis
                write (error_unit,'(1X,"Number of core electrons: ",i0,".")') sys%nel-sys%cas(1)
                write (error_unit,'(1X,"Number of possible active spin-orbitals: ",i0,".")') sys%basis%nbasis-(sys%nel-sys%cas(1))
                write (error_unit,'(1X,"Number of active spin-orbitals in CAS: ",i0,".")') 2*sys%cas(2)
                call stop_all('read_in_integrals', 'CAS cannot have more active basis functions than in the system')
            end if
        end if

        ! Determine if appropriate information is available to use translational symmetry
        momentum_sym = sum(abs(nprop - [-1, -1, -1])) >= depsilon .and. propbitlen /= -1
        if (momentum_sym) then
            if (sys%read_in%comp) then
                sys%lattice%ndim = 3
                sys%momentum_space = .true.
                sys%read_in%mom_sym%nprop = nprop
                sys%read_in%mom_sym%propbitlen = propbitlen
                sys%read_in%uhf = .false.
                if (minval(orbsym(1:norb)) < 0) then
                    if (parent) write (iunit,'(1X,a62,/)') 'Unconverged symmetry found.  Turning translational symmetry off.'
                    orbsym(:) = 0_int_64
                end if
            else
                ! If system isn't complex but contains symmetry information, must have real supercell with
                ! single kpoint. In this case using momentum symmetry or pg symmetry will make no difference,
                ! so we use pg_sym for easy compatibility with conventional routines.
                momentum_sym = .false.
                if (parent) write (iunit,'(1X,a62,/)') 'Performing supercell calculation.  Turning symmetry off.'
                orbsym(:) = 0_int_64
            end if
        end if
        ! Set system properties required later

        ! Read in FCIDUMP file to get single-particle eigenvalues.
        allocate(sp_eigv(norb), stat=ierr)
        call check_allocate('sp_eigv', norb, ierr)
        if (parent) call get_sp_eigv(sys, ir, sp_eigv)

#ifdef PARALLEL
        call MPI_BCast(sp_eigv, norb, mpi_preal, root, MPI_COMM_WORLD, ierr)
#endif

        ! Rank basis functions by single-particle energy.
        ! Note that we use a *stable* ranking algorithm.
        allocate(sp_eigv_rank(0:norb), stat=ierr)
        call check_allocate('sp_eigv_rank', norb+1, ierr)
        allocate(sp_fcidump_rank(0:norb), stat=ierr)
        call check_allocate('sp_fcidump_rank', norb+1, ierr)

        if (sys%read_in%uhf) then
            ! Cannot simply naively sort all basis functions by energy as that
            ! causes basis functions to be labelled with the incorrect spin.
            ! Further we assume that basis functions have alternating alpha, beta
            ! spins.  To overcome this we sort by energy within each spin and then
            ! merge the two ranking orders.
            ! Yes, this the calls to insertion_rank do result in array copies,
            ! but the arrays are small and the elegance and brevity of the code is
            ! more than aadequate compensation.
            call insertion_rank(sp_eigv(1::2), sp_eigv_rank(1::2), tolerance=depsilon)
            call insertion_rank(sp_eigv(2::2), sp_eigv_rank(2::2), tolerance=depsilon)
            ! Interweave so the basis functions remain with alternating spins.
            forall (i = 1:sys%basis%nbasis-1:2)
                sp_eigv_rank(i) = 2*sp_eigv_rank(i) - 1
                sp_eigv_rank(i+1) = 2*sp_eigv_rank(i+1)
            end forall
        else
            ! RHF case is much easier, as spin channels are degenerate and have
            ! the same spatial components.
            call insertion_rank(sp_eigv(1:), sp_eigv_rank(1:), tolerance=depsilon)
        end if

        ! the 0 index is used as a null entry in the FCIDUMP file, so need
        ! to handle that...
        sp_eigv_rank(0) = 0

        ! sp_eigv_rank(i) = i' takes us from the {i'} basis (as ordered in
        ! the FCIDUMP file) to the {i} basis (ordered by energy).  We also
        ! need the inverse.
        do i = 0, norb
            do j = 0, norb
                if (sp_eigv_rank(j) == i) then
                    sp_fcidump_rank(i) = j
                    exit
                end if
            end do
        end do

        ! Set up basis functions, including those which are subsequently frozen.
        allocate(all_basis_fns(sys%basis%nbasis), stat=ierr)
        call check_allocate('all_basis_fns', sys%basis%nbasis, ierr)
        call init_basis_fns_read_in(norb, sys, orbsym, symlz,  sp_eigv, sp_eigv_rank(1:), all_basis_fns)

        ! From sys%CAS work out the start of the active basis functions, the number
        ! of active basis functions and the number of active electrons.

        ! NOTE: this sets sys%basis%nbasis to be the number of spin orbitals in the active
        ! basis.

        if (all(sys%cas > 0)) then
            active_basis_offset = sys%nel-sys%cas(1) ! number of core *spin* orbitals
            ! Note that sys%basis%nbasis is spin-orbitals whereas cas(2)=M is in spatial orbitals
            ! (as we use the conventional CAS definition).
            sys%basis%nbasis = 2*sys%cas(2)
            sys%nel = sys%cas(1)
        else
            active_basis_offset = 0
        end if
        sys%nvirt = sys%basis%nbasis - sys%nel
        if (sys%read_in%uhf) then
            norb =  sys%basis%nbasis
        else
            norb = sys%basis%nbasis/2
        end if

        ! Set up basis functions used in calculation.
        allocate(sys%basis%basis_fns(sys%basis%nbasis), stat=ierr)
        call check_allocate('sys%basis%basis_fns', sys%basis%nbasis, ierr)
        call init_basis_fns_read_in(norb, sys, orbsym,  symlz, sp_eigv, &
                                    sp_eigv_rank(1+active_basis_offset/rhf_fac:), sys%basis%basis_fns)

        deallocate(sp_eigv, stat=ierr)
        call check_deallocate('sp_eigv', ierr)

        ! Was a symmetry found for all basis functions?  If not, then we must
        ! turn symmetry off.
        if (.not. momentum_sym .and. minval(sys%basis%basis_fns(:)%sym) < 0) then
            if (parent) write (iunit,'(1X,a62,/)') 'Unconverged symmetry found.  Turning point group symmetry off.'
            forall (i=1:sys%basis%nbasis) sys%basis%basis_fns(i)%sym = 0
        end if

        ! Set up symmetry information.
        if (t_store) then
            if (momentum_sym) then
                call init_read_in_momentum_symmetry(sys)
            else
                call init_pg_symmetry(sys)
            end if
        end if
        ! Initialise integral stores.
        ! If using momentum symmetry don't use value of op_sym currently, so can set to read_in value (which
        ! will be default value) even if not valid in system.
        if (t_store) then
            call init_one_body_t(sys, sys%read_in%pg_sym%gamma_sym, .false., sys%read_in%one_e_h_integrals)
            call init_two_body_t(sys, sys%read_in%pg_sym%gamma_sym, .false., sys%read_in%coulomb_integrals)
            if (sys%read_in%comp) then
                call init_one_body_t(sys, sys%read_in%pg_sym%gamma_sym, .true., sys%read_in%one_e_h_integrals_imag)
                call init_two_body_t(sys, sys%read_in%pg_sym%gamma_sym, .true., sys%read_in%coulomb_integrals_imag)
            end if
        end if

        if (parent) then
            ! Now, read in FCIDUMP again to get the integrals.
            ! Don't use rewind to avoid gcc 7.1.0 bug: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80741
            close(ir)
            open (newunit=ir, file=sys%read_in%fcidump, status='old', form='formatted')
            ! Have to re-read the FCI namelist.
            ! ***WARNING***
            ! This will, e.g. overwrite norb, but we don't need those variables any
            ! more.
            read(ir,FCI)
        end if

        ! Freezing core orbitals amounts to changing the Hamiltonian.  In
        ! particular:

        ! E_core = E_nuc + \sum_{i=1}^{N_fr} <i|h|i> + \sum_{i<j}^{N_fr} <ij|ij> - <ij|ji>  [1]
        ! <a|h'|b> = <a|h|b> + \sum_{i=1}^{N_fr} <ia|ib> - <ia|bi>                          [2]

        ! where we use i,j to refer to frozen core spin-orbitals and a,b to refer to
        ! active spin-orbitals.

        ! See J. Chem. Phys. 62, 4764 (1975), An Introduction to
        ! Configuration Interaction Theory by C. David Sherrill
        ! (http://vergil.chemistry.gatech.edu/notes/ci/ci.html) and
        ! Alex Thom's thesis.

        ! We don't wish to incur the overhead of ever storing integrals
        ! involving frozen orbitals so instead we simply accumulate the
        ! quantities above.  Hence we must zero them.
        ! Furthermore, some integrals, which are allowed to be non-zero by the
        ! symmetry information provided, might be zero and so not included in
        ! FCIDUMP.  We must zero the stores to hence avoid accessing unitialised
        ! memory.

        sys%read_in%Ecore = 0.0_p
        im_core = 0.0_p
        if (t_store) then
            call zero_one_body_int_store(sys%read_in%one_e_h_integrals)
            call zero_two_body_int_store(sys%read_in%coulomb_integrals)
            if (sys%read_in%comp) then
                call zero_one_body_int_store(sys%read_in%one_e_h_integrals_imag)
                call zero_two_body_int_store(sys%read_in%coulomb_integrals_imag)
            end if
        end if

        ! Now, there is no guarantee that FCIDUMP files will include all
        ! permutation symmetry and so we must avoid double-counting when
        ! accumulating Ecore and <a|h'|b>.

        ! * <i|h|i> can only occur once (and requires a factor of 2 in RHF
        !   calculations), hence there is no risk of double counting.
        ! * <ij|ij> and <ij|ji>: store whether seen in a triangular array.
        ! * <ia|ib> and <ia|bi>: store whether seen in a triangular array for
        !   each i.

        ! In the 'seen' arrays, +1 indicates the Coulomb integral has already
        ! been seen and +2 indicates the exchange integral has already been
        ! seen.  We only vaguely attempt to save memory in these arrays (ie one
        ! can do better if needed---see integral stores in molecular_integrals
        ! for inspiration).

        ! We similarly need to remember if we've seen <i|h|a> or <a|h|i> as we
        ! only store one of the pair.

        ! If using complex orbitals, <ii|jj> =/= <ij|ji>, etc, so no longer
        ! accept some permutations.
        ! For complex have also assumed expressions above for E_core and <a|h'|b>
        ! hold; if not the case then likely incorrect values obtained.

        ! Accumulate errors so we can print out (at most) max_err_msg errors from this file.
        int_err = 0
        max_err_msg = 10

        if (parent) then

            allocate(seen_iha((sys%basis%nbasis*(sys%basis%nbasis+1))/2), stat=ierr)
            call check_allocate('seen_iha', sys%basis%nbasis*(sys%basis%nbasis+1)/2, ierr)
            allocate(seen_ijij((active_basis_offset*(active_basis_offset+1))/2), stat=ierr)
            call check_allocate('seen_ijij', active_basis_offset*(active_basis_offset+1)/2, ierr)
            allocate(seen_iaib(-active_basis_offset+1:0,(sys%basis%nbasis*(sys%basis%nbasis+1))/2), stat=ierr)
            call check_allocate('seen_iaib', sys%basis%nbasis*(sys%basis%nbasis+1)/2, ierr)
            seen_iha = .false.
            seen_ijij = 0
            seen_iaib = 0

            ! Freezing virtual orbitals amounts to simply not exciting into them,
            ! which can easily be enforced by removing them from the basis set.

            ! read integrals and eigenvalues
            ios = 0
            do

                ! loop over lines.
                if (sys%read_in%comp) then
                    read (ir,*, iostat=ios) compint, i, a, j, b
                    x=real(compint,p)
                    y=aimag(compint)
                else
                    read (ir,*, iostat=ios) x, i, a, j, b
                end if

                if (ios == iostat_end) exit ! reached end of file
                if (ios /= 0) call stop_all('read_in_integrals', &
                                            'Problem reading integrals file: '//trim(sys%read_in%fcidump))

                ! Working in spin orbitals but FCIDUMP is in spatial orbitals in RHF
                ! calculations and spin orbitals in UHF calculations, and te basis
                ! is ! not necessarily ordered by energy.  We wish to work in spin
                ! orbitals ordered by energy.
                ! Need to only store integrals in one spin-channel in RHF, so
                ! can just get away with referring (e.g.) beta orbitals, hence the
                ! factor of 2 in RHF.  The integral store routines convert the
                ! indices further to compress the integral stores as much as
                ! possible.
                i = rhf_fac*sp_fcidump_rank(i)
                j = rhf_fac*sp_fcidump_rank(j)
                a = rhf_fac*sp_fcidump_rank(a)
                b = rhf_fac*sp_fcidump_rank(b)

                ! Adjust indices to take into account frozen core orbitals and to
                ! convert to an energy ordering.
                ii = i - active_basis_offset
                jj = j - active_basis_offset
                aa = a - active_basis_offset
                bb = b - active_basis_offset

                if (max(ii,jj,aa,bb) <= sys%basis%nbasis) then

                    ! Have integrals involving only core or active orbitals.
                    if (i == 0 .and. j == 0 .and. a == 0 .and. b == 0) then

                        ! Nuclear energy.
                        sys%read_in%Ecore = sys%read_in%Ecore + x
                        if (sys%read_in%comp) then
                            ! Imaginary component should be 0 but just in case...
                            im_core = im_core + y
                        end if
                    else if (i > 0 .and. j == 0 .and. a == 0 .and. b == 0) then

                        ! \epsilon_i
                        ! Already dealt with in previous pass over FCIDUMP.

                    else if (j == 0 .and. b == 0) then

                        ! < i | h | a >
                        if (t_store) then
                            if (ii < 1 .and. ii == aa) then
                                ! Have <i|h|i> from a core orbital.  Add
                               ! contribution to sys%read_in%Ecore.
                                ! If RHF need to include <i,up|h|i,up> and
                                ! <i,down|h|i,down>.
                                sys%read_in%Ecore = sys%read_in%Ecore + x*rhf_fac
                                if (sys%read_in%comp) then
                                    im_core = im_core + y*rhf_fac
                                end if
                            else if (all( (/ ii, aa /) > 0)) then
                                if (.not.seen_iha(tri_ind_reorder(ii,aa))) then
                                    x = x + get_one_body_int_mol_real(sys%read_in%one_e_h_integrals, ii, aa, &
                                                                 sys)
                                    call store_one_body_int(ii, aa, x, sys, int_err > max_err_msg, &
                                                            sys%read_in%one_e_h_integrals, ierr)
                                    int_err = int_err + ierr
                                    if (sys%read_in%comp) then
                                        y = y + get_one_body_int_mol_real(sys%read_in%one_e_h_integrals_imag, ii, aa, &
                                                                     sys)
                                        call store_one_body_int(ii, aa, y, sys, int_err > max_err_msg, &
                                                                sys%read_in%one_e_h_integrals_imag, ierr)
                                        int_err = int_err + ierr
                                    end if

                                    seen_iha(tri_ind_reorder(ii,aa)) = .true.
                                end if
                            end if
                        end if

                    else

                        ! < i j | 1/r_12 | a b >
                        if (t_store) then
                            orbs = (/ ii, jj, aa, bb /)
                            select case(count(orbs > 0))
                            case(0)
                                ! Have <ij|ab> involving only core orbitals.
                                ! We should only run over i<j but there's no
                                ! guarantee that the FCIDUMP file contains the
                                ! permutations we expect (ie it might contain
                                ! <ji|ji> but not <ij|ij>, where i<j), so
                                ! instead we let the seen_ijij array make sure
                                ! we only use a unique integral once, no matter
                                ! which permutation(s) occur in the FCIDUMP
                                ! file.
                                ! For core orbitals, sum imaginary components;
                                ! if overall core energy has non-negligible
                                ! imaginary component raise error as something
                                ! gone wrong.
                                if (ii == aa .and. jj == bb .and. ii == jj) then
                                    if (.not.sys%read_in%uhf .and. mod(seen_ijij(tri_ind_reorder(i,j)),2) == 0) then
                                        ! RHF calculations: need to include <i,up i,down|i,up i,down>.

                                        sys%read_in%Ecore = sys%read_in%Ecore + x
                                        if (sys%read_in%comp) then
                                            im_core = im_core + y
                                        end if
                                        seen_ijij(tri_ind_reorder(i,j)) = seen_ijij(tri_ind_reorder(i,j)) + 1
                                    end if
                                else if (ii == aa .and. jj == bb .and. ii /= jj) then
                                    ! <ij|ij>, i/=j
                                    if (mod(seen_ijij(tri_ind_reorder(i,j)),2) == 0) then
                                        ! If RHF, then need to include:
                                        !   <i,up j,up|i,up, j,up>
                                        !   <i,up j,down|i,up, j,down>
                                        !   <i,down j,up|i,down, j,up>
                                        !   <i,down j,down|i,down, j,down>
                                        sys%read_in%Ecore = sys%read_in%Ecore + x*rhf_fac**2
                                        if (sys%read_in%comp) then
                                            im_core = im_core + y*rhf_fac**2
                                        end if
                                        seen_ijij(tri_ind_reorder(i,j)) = seen_ijij(tri_ind_reorder(i,j)) + 1
                                    end if
                                else if (ii == bb .and. jj == aa .and. ii /= jj .or. &
                                         (ii == jj .and. aa == bb .and. ii /= aa .and. .not. sys%read_in%comp)) then
                                    ! <ij|ji>, i/=j (or <ii|jj> version) can be treated together if real orbitals
                                    ! but not if complex orbitals.
                                    ! Only accept complex if is <ij|ji>
                                    if (ii == jj) then
                                        ti = tri_ind_reorder(i, a)
                                    else
                                        ti = tri_ind_reorder(i, j)
                                    end if
                                    if (seen_ijij(ti) < 2) then
                                        ! If RHF, then need to include:
                                        !   <i,up j,up|j,up, i,up>
                                        !   <i,down j,down|j,down, i,down>
                                        sys%read_in%Ecore = sys%read_in%Ecore - rhf_fac*x
                                        if (sys%read_in%comp) then
                                            im_core = im_core - rhf_fac*y
                                        end if
                                        seen_ijij(ti) = seen_ijij(ti) + 2
                                    end if
                                end if
                            case(2)
                                ! Have an integral involving two core and two active orbitals.
                                ic = 1
                                ia = 1
                                do iorb = 1, 4
                                    if (orbs(iorb) > 0) then
                                        active(ia) = orbs(iorb)
                                        ia = ia +1
                                    else
                                        core(ic) = orbs(iorb)
                                        ic = ic + 1
                                    end if
                                end do
                                if (core(1) == core(2)) then
                                    ! Have integral of type < i a | i b > or < i a | b i >,
                                    ! where i is a core orbital and a and b are
                                    ! active orbitals.
                                    if ((ii == core(1) .and. aa == core(1)) .or. (jj == core(1) .and. bb == core(1))) then
                                        ! < i a | i b > or < a i | b i >
                                        if (mod(seen_iaib(core(1), tri_ind_reorder(active(1),active(2))),2) == 0) then
                                            ! Update <a|h|b> with contribution <ia|ib>.
                                            x = x*rhf_fac + &
                                                get_one_body_int_mol_real(sys%read_in%one_e_h_integrals, active(1), &
                                                                     active(2), sys)
                                            call store_one_body_int(active(1), active(2), x, sys, int_err > max_err_msg, &
                                                                        sys%read_in%one_e_h_integrals, ierr)
                                            int_err = int_err + ierr
                                            if (sys%read_in%comp) then
                                                y = y*rhf_fac + &
                                                    get_one_body_int_mol_real(sys%read_in%one_e_h_integrals_imag, active(1), &
                                                                         active(2), sys)
                                                call store_one_body_int(active(1), active(2), y, sys, int_err > max_err_msg, &
                                                                            sys%read_in%one_e_h_integrals_imag, ierr)
                                                int_err = int_err + ierr
                                            end if
                                            seen_iaib(core(1), tri_ind_reorder(active(1),active(2))) = &
                                                seen_iaib(core(1), tri_ind_reorder(active(1),active(2))) + 1
                                        end if
                                    else if ((.not. sys%read_in%comp) .or. ((ii == core(1) .and. bb == core(2)) &
                                                .or. (jj == core(1) .and. aa == core(2)))) then
                                        ! < i a | b i > (or allowed permutation thereof)
                                        ! For systems with complex orbitals (but real integrals)
                                        ! it's possible for <ii|ba> to be nonzero, but <ia|bi>=0 so we test sym

                                        ! For complex we can only accept <ia|bi> or <ai|ib>, which gives the second two
                                        ! conditions above.
                                        ! For real we can also accept <ii|ab>/<ii|ba> etc, which are all remaining cases
                                        ! of core(1) == core(2) after the inital if statement. As such if real automatically
                                        ! accept.
                                        if (seen_iaib(core(1), tri_ind_reorder(active(1),active(2))) < 2 .and. &
                                            is_gamma_irrep_read_in(sys%read_in%pg_sym, &
                                                sys%read_in%cross_product_sym_ptr(sys%read_in, &
                                                            sys%read_in%sym_conj_ptr(sys%read_in, &
                                                            sys%basis%basis_fns(active(1))%sym), &
                                                            sys%basis%basis_fns(active(2))%sym))) then
                                            ! Update <j|h|a> with contribution <ij|ai>.
                                            x = get_one_body_int_mol_real(sys%read_in%one_e_h_integrals, active(1), active(2), &
                                                                     sys)  - x
                                            call store_one_body_int(active(1), active(2), x, sys, int_err > max_err_msg, &
                                                                        sys%read_in%one_e_h_integrals, ierr)
                                            int_err = int_err + ierr
                                            if (sys%read_in%comp) then
                                                ! Possible sign change due to ordering of active(1) & active(2) accounted for in get_one_body...
                                                ! and store_one_body... function ordering adjustments.
                                                y = get_one_body_int_mol_real(sys%read_in%one_e_h_integrals_imag, active(1), &
                                                                        active(2), sys)  - y
                                                call store_one_body_int(active(1), active(2), y, sys, int_err > max_err_msg, &
                                                                            sys%read_in%one_e_h_integrals_imag, ierr)
                                                int_err = int_err + ierr
                                            end if
                                            seen_iaib(core(1), tri_ind_reorder(active(1),active(2))) = &
                                                seen_iaib(core(1), tri_ind_reorder(active(1),active(2))) + 2
                                        end if
                                    end if
                                end if
                            case(4)
                                ! Have <ij|ab> involving active orbitals.
                                call store_two_body_int(ii, jj, aa, bb, x, sys, int_err > max_err_msg, &
                                                        sys%read_in%coulomb_integrals, ierr)
                                int_err = int_err + ierr
                                if (sys%read_in%comp) then
                                    call store_two_body_int(ii, jj, aa, bb, y, sys, int_err > max_err_msg, &
                                                sys%read_in%coulomb_integrals_imag, ierr)
                                    int_err = int_err + ierr
                                end if
                            end select
                        end if

                    end if

                end if

            end do

            if (int_err /= 0) then
                write (err_msg, '("Found and ignored",'//int_fmt(int_err,1)//'," integrals which should be zero &
                                  &by symmetry in file: '//trim(sys%read_in%fcidump)//'")') int_err
                call warning('read_in_integrals', trim(err_msg), 1)
                if (int_err > max_err_msg) &
                    write (iunit,'(1X,"Only the first",'//int_fmt(max_err_msg)//'," error messages are shown.",/)') max_err_msg
            end if

            ! If system is sensible, total Ecore including any CAS contribution will be purely real as is just the sum of Ecore and single
            ! particle energies of core orbitals; if not then either these assumptions are wrong or something's up with the INTDUMP.
            ! Either way will want to know.
            if (abs(im_core) > depsilon) then
                call stop_all('read_in_integrals' ,'Nonzero imaginary core energy found; check your CAS settings.')
            end if

            deallocate(seen_iha, stat=ierr)
            call check_deallocate('seen_iha', ierr)
            deallocate(seen_ijij, stat=ierr)
            call check_deallocate('seen_ijij', ierr)
            deallocate(seen_iaib, stat=ierr)
            call check_deallocate('seen_iaib', ierr)
            close(ir, status='keep')

        end if

#ifdef PARALLEL
        call MPI_BCast(sys%read_in%Ecore, 1, mpi_preal, root, MPI_COMM_WORLD, ierr)
#endif
        call broadcast_one_body_t(sys%read_in%one_e_h_integrals, root)
        call broadcast_two_body_t(sys%read_in%coulomb_integrals, root, sys%read_in%max_broadcast_chunk)
        if (sys%read_in%comp) then
            call broadcast_one_body_t(sys%read_in%one_e_h_integrals_imag, root)
            call broadcast_two_body_t(sys%read_in%coulomb_integrals_imag, root, sys%read_in%max_broadcast_chunk)
        end if

        if (sys%read_in%extra_exchange_integrals) call read_additional_exchange_integrals(sys, sp_fcidump_rank, t_verbose)

        if (size(sys%basis%basis_fns) /= size(all_basis_fns) .and. parent .and. t_verbose) then
            ! We froze some orbitals...
            ! Print out entire original basis.
            call write_basis_fn_header(sys)
            do i = 1, size(all_basis_fns)
                call write_basis_fn(sys, all_basis_fns(i), ind=i, new_line=.true.)
            end do
            write (iunit,'(/,1X,"Freezing...",/,1X,"Using complete active space: (",i0,",",i0,")",/)') sys%cas
        end if

        call dealloc_basis_fn_t_array(all_basis_fns)

        if (parent .and. t_verbose) then
            call write_basis_fn_header(sys)
            do i = 1, sys%basis%nbasis
                call write_basis_fn(sys, sys%basis%basis_fns(i), ind=i, new_line=.true.)
            end do
            write (iunit,'(/,1X,a8,f18.12)') 'E_core =', sys%read_in%Ecore
        else if (parent) then
            call write_basis_fn_title()
        end if

        if (t_store .and. sys%read_in%dipole_int_file /= '') then
            call read_in_one_body(sys%read_in%dipole_int_file, sys, &
                                  sp_fcidump_rank, active_basis_offset, sys%read_in%one_body_op_integrals, &
                                  sys%read_in%dipole_core)
        end if

        deallocate(sp_eigv_rank, stat=ierr)
        call check_deallocate('sp_eigv_rank', ierr)
        deallocate(sp_fcidump_rank, stat=ierr)
        call check_deallocate('sp_fcidump_rank', ierr)

        if (.not.t_store) then
            ! Should tidy up and deallocate everything we allocated.
            call dealloc_basis_fn_t_array(sys%basis%basis_fns)
        end if

    end subroutine read_in_integrals

    subroutine init_basis_fns_read_in(norb, sys, orbsym, lz, sp_eigv, sp_eigv_rank, basis_arr)

        ! Initialise list of basis functions based upon the FCI namelist`data
        ! read in from an FCIDUMP file.

        ! In:
        !    norb: number of orbitals/functions to initialise.  Refers to
        !         spatial orbitals in a RHF-based FCIDUMP file and spin orbitals
        !         in a UHF-based FCIDUMP file.
        !    sys: system being studied.  sys%read_in%uhf must be true if FCIDUMP
        !         file was produced from an unrestricted (UHF) calculation.
        !    orbsym: list of symmetries of each orbital/function.
        !    lz:  the lz of the orbitals.  Can be just zero.
        !    sp_eigv: single-particle eigenvalues of each orbital/function.
        !    sp_eigv_rank: rank of each orbital/function by the single-particle
        !         eigenvalue.
        !
        ! Note: input arrays *must* have at least norb set elements.  Only the
        ! first norb elements are used.  In RHF systems the up and down spin
        ! orbitals have identical eigenvalues and symmetries (due to sharing the
        ! same spatial orbitals).
        !
        ! In/Out:
        !    basis_arr: array of (spin) basis functions.  On entry it is
        !    allocated to (at least) the size of the basis.  On exit the
        !    individual basis_fn_t elements have been initialised and symmetry and
        !    spatial_index information assigned.
        !    If we have momentum symmetry, will have assigned l values rather than
        !    sym.

        use basis, only: basis_fn_t, init_basis_fn
        use system, only: sys_t
        use const, only: int_32, int_64
        use momentum_sym_read_in, only: decompose_trans_sym, get_kpoint_index

        type(sys_t), intent(in) :: sys
        integer, intent(in) :: norb
        integer(int_64), intent(in) :: orbsym(:)
        integer, intent(in) :: lz(:)
        real(p), intent(in) :: sp_eigv(:)
        integer, intent(in) :: sp_eigv_rank(:)
        type(basis_fn_t), intent(inout) :: basis_arr(:)

        integer :: i, rank, kpoint_vector(3), ksym_index

        do i = 1, norb
            rank = sp_eigv_rank(i)
            if (sys%read_in%uhf) then
                if (sys%momentum_space) then
                    call decompose_trans_sym(orbsym(rank), sys%read_in%mom_sym%propbitlen, kpoint_vector)
                    ksym_index = get_kpoint_index(kpoint_vector, sys%read_in%mom_sym%nprop)
                    if (mod(i,2) == 0) then
                        call init_basis_fn(sys, basis_arr(i), l=kpoint_vector, lz=lz(rank), sym=ksym_index, ms=-1)
                    else
                        call init_basis_fn(sys, basis_arr(i), l=kpoint_vector, lz=lz(rank), sym=ksym_index, ms=1)
                    end if

                else
                    if (mod(i,2) == 0) then
                        call init_basis_fn(sys, basis_arr(i), sym=int(orbsym(rank)-1, kind=int_32), lz=lz(rank), ms=-1)
                    else
                        call init_basis_fn(sys, basis_arr(i), sym=int(orbsym(rank)-1, kind=int_32), lz=lz(rank), ms=1)
                    end if
                end if
                ! Assume orbitals are ordered appropriately in FCIDUMP...
                basis_arr(i)%spatial_index = (i+1)/2
                basis_arr(i)%sp_eigv = sp_eigv(rank)
            else
                ! Need to initialise both up- and down-spin basis functions.
                ! If we have translational symmetry to account for want to have different basis function info.
                if (sys%momentum_space) then
                    call decompose_trans_sym(orbsym(rank), sys%read_in%mom_sym%propbitlen, kpoint_vector)
                    ksym_index = get_kpoint_index(kpoint_vector, sys%read_in%mom_sym%nprop)
                    call init_basis_fn(sys, basis_arr(2*i), l=kpoint_vector, lz=lz(rank), sym=ksym_index, ms=-1)
                    call init_basis_fn(sys, basis_arr(2*i-1), l=kpoint_vector, lz=lz(rank), sym=ksym_index, ms=1)
                else
                    call init_basis_fn(sys, basis_arr(2*i), sym=int(orbsym(rank)-1, kind=int_32), lz=lz(rank), ms=-1)
                    call init_basis_fn(sys, basis_arr(2*i-1), sym=int(orbsym(rank)-1, kind=int_32), lz=lz(rank), ms=1)
                end if
                basis_arr(2*i-1)%spatial_index = i
                basis_arr(2*i)%spatial_index = i
                basis_arr(2*i-1)%sp_eigv = sp_eigv(rank)
                basis_arr(2*i)%sp_eigv = sp_eigv(rank)
            end if
        end do

    end subroutine init_basis_fns_read_in

    subroutine read_in_one_body(integral_file, sys, sp_fcidump_rank, active_basis_offset, &
                                store, core_term)

        ! Read in an integral file containing the integrals <i|O|a>, where O is
        ! a one-body operator which is not part of the Hamiltonian.

        ! The integral file consists soley of lines with the format:
        !    x i a
        ! where <i|O|a> = x.

        ! We assume the orbitals have the same indexing as used in the FCIDUMP
        ! file and i,a are in spatial (spin) indices if produced by a RHF (UHF)
        ! calculation.

        ! In:
        !    integral_file: file containing integrals.
        !    sys: object containing information on the system. We use:
        !           -sys%basis%nbasis
        !           -sys%basis%basis_fns
        !           -sys%read_in%uhf
        !           -sys%read_in%pg_sym
        !    sp_fcidump_rank: ranking array which converts index in the
        !         integrals file(s) to the (energy-ordered) index used in HANDE,
        !         i.e. sp_fcidump_rank(a) = i, where a is the a-th
        !         orbital according to the ordering used in the integral files
        !         and i is the i-th orbital by energy ordering.
        !         Note: must be 0-indexed and sp_fcidump_rank(0) = 0.  See above
        !         commments about this special case.
        !    active_basis_offset: number of frozen core orbitals.
        ! Out:
        !    store: one-body store of integrals given in integral_file..
        !    core_term: contribution to <\Psi|O|\Psi> from the
        !         frozen core orbitals and the nucleii.

        use basis_types, only: basis_fn_t
        use read_in_symmetry, only: cross_product_basis_read_in
        use symmetry_types, only: pg_sym_t
        use molecular_integrals, only: one_body_t, init_one_body_t,              &
                                       end_one_body_t, store_one_body_int, &
                                       zero_one_body_int_store, broadcast_one_body_t

        use errors, only: stop_all
        use parallel
        use utils, only: int_fmt
        use errors, only: warning
        use system, only: sys_t

        use, intrinsic :: iso_fortran_env, only: iostat_end

        character(*), intent(in) :: integral_file
        type(sys_t), intent(in) :: sys
        integer, intent(in) :: sp_fcidump_rank(0:), active_basis_offset
        type(one_body_t), intent(out) :: store
        real(p), intent(out) :: core_term

        integer :: ir, op_sym, ios, i, a, ii, aa, rhf_fac, ierr
        logical :: t_exists
        integer :: int_err, max_err_msg, iunit
        character(1024) :: err_msg

        real(p) :: x

        iunit = 6

        ! Accumulate errors so we can print out (at most) max_err_msg errors from this file.
        int_err = 0
        max_err_msg = 10

        if (sys%read_in%uhf) then
            rhf_fac = 1
        else
            rhf_fac = 2  ! need to double count some integrals.
        end if

        ! Only do i/o on root processor.
        if (parent) then
            ! We don't know the symmetry of the operator.
            ! However, we do know that a non-zero integral must have a totally
            ! symmetric integrand *and* we know the symmetries of all the orbitals.
            inquire(file=integral_file, exist=t_exists)
            if (.not.t_exists) call stop_all('read_in_one_body', 'Integral file does not &
                                                               &exist:'//trim(integral_file))
            open (newunit=ir, file=integral_file, status='old', form='formatted')

            do
                read (ir,*, iostat=ios) x, i, a
                if (ios == iostat_end) exit ! reached end of file
                if (ios /= 0) call stop_all('read_in_one_body','Problem reading integrals file: '//trim(integral_file))
                ii = rhf_fac*sp_fcidump_rank(i) - active_basis_offset
                aa = rhf_fac*sp_fcidump_rank(a) - active_basis_offset
                if (abs(x) > depsilon .and. ii > 0 .and. aa > 0) exit ! Found the first non-zero integral in active space.
            end do
            ! We only use Abelian symmetries so all representations are their own
            ! inverse.
            op_sym = cross_product_basis_read_in(sys, ii,aa)
        else
            ! We'll broadcast the symmetry and the integrals to all other
            ! processors later.
            op_sym = -1
        end if

        ! Allocate integral store on *all* processors.
        if (allocated(store%integrals)) call end_one_body_t(store)
        call init_one_body_t(sys, op_sym, .false., store)
        ! Integrals might be allowed by symmetry (and hence stored) but still
        ! be zero (and so not be included in the integral file).  To protect
        ! ourselves against accessing uninitialised memory:
        call zero_one_body_int_store(store)

        ! In addition to reading in the integrals, we must also calculate the
        ! contribution from the core (frozen) orbitals.
        !
        ! Consider |\Psi> = c_i |D_i>, where {|D_i>} includes the frozen core
        ! electrons and Einstein summation is used throughout. Then:
        !
        !     <\Psi | O | \Psi> = <D_i|O|D_j> c_i^* c_j
        !
        ! where, for spin-orbitals {|a>}:
        !
        !     <D_i|O|D_j> = | <a|O|a> if |D_i>=|D_j>
        !                   | <a|O|b> if |D_i> and |D_j> are related by the excitation a->b
        !                   | 0       otherwise
        !
        !     <\Psi |O | \Psi > = <a_c|O|a_c> c_i^* c_i + <D_i'|O|D_j'> c_i^* c_j
        !
        ! where {|D_i'>} now only incude active occupied orbitals and {|a_c>} are
        ! the frozen core electrons.  As {|a_c>} is indentical for all
        ! determinants and |\Psi> is normalised, the summation over i in the first
        ! term is unity and hence:
        !
        !     <\Psi |O | \Psi > = <a_c|O|a_c> + <D_i'|O|D_j'> c_i^* c_j
        !
        ! The contribution from the frozen core electrons is hence just the sum
        ! over the diagonal integrals.

        ! And back to root...
        core_term = 0.0_p
        if (parent) then
            ! Don't use rewind to avoid gcc 7.1.0 bug: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80741
            close(ir)
            open(newunit=ir, file=integral_file, status='old', form='formatted')
            do
                read (ir,*, iostat=ios) x, i, a
                if (ios == iostat_end) exit ! reached end of file
                if (ios /= 0) call stop_all('read_in_one_body','Problem reading integrals file: '//trim(integral_file))
                ii = rhf_fac*sp_fcidump_rank(i) - active_basis_offset
                aa = rhf_fac*sp_fcidump_rank(a) - active_basis_offset
                if (i == 0 .and. a == 0) then
                    ! Nuclear contributions.
                    core_term = core_term + x
                else if (ii < 1 .and. ii == aa) then
                    core_term = core_term + rhf_fac*x
                else if (min(ii,aa) >= 1 .and. max(ii,aa) <= sys%basis%nbasis) then
                    call store_one_body_int(ii, aa, x, sys, &
                                            int_err > max_err_msg, store, ierr)
                    int_err = int_err + ierr
                end if
            end do
        end if

        if (int_err /= 0) then
            write (err_msg, '("Found and ignored",'//int_fmt(int_err,1)//'," integrals which should be zero &
                              &by symmetry in file: '//trim(integral_file)//'")') int_err
            call warning('read_in_one_body', trim(err_msg), 1)
            if (int_err > max_err_msg) &
                write (iunit,'(1X,"Only the first",'//int_fmt(max_err_msg)//'," error messages are shown.",/)') max_err_msg
        end if


        ! And now send info everywhere...
#ifdef PARALLEL
        call MPI_BCast(core_term, 1, mpi_preal, root, MPI_COMM_WORLD, ierr)
#endif
        call broadcast_one_body_t(store, root)

    end subroutine read_in_one_body

    subroutine get_sp_eigv(sys, ir, sp_eigv)
        
        ! Get Fock energies: either read from FCIDUMP or calculate from other integrals if not provided

        ! In:
        !   sys: system being studied
        !   ir: open FCIDUMP file
        ! Out:
        !   sp_eigv: calculated single-particle eigenvalues.

        use system, only: sys_t
        use errors, only: stop_all, warning
        use, intrinsic :: iso_fortran_env, only: iostat_end

        type(sys_t), intent(in) :: sys
        integer, intent(in) :: ir
        real(p), intent(out) :: sp_eigv(:)

        integer :: ios, i, a, j, b
        real(p) :: x
        complex(p) :: compint

        integer :: nocc
        logical :: seen_ijij(size(sp_eigv), size(sp_eigv)), seen_ijji(size(sp_eigv), size(sp_eigv)), found_sp_eigv

        ! Assume first nelec/2 orbitals are doubly occupied
        nocc = sys%nel/2

        found_sp_eigv = .false.
        sp_eigv = 0.0_p
        ! Don't know what duplicates may be in FCIDUMP: avoid double counting
        seen_ijij = .false.
        seen_ijji = .false.

        do
            ! loop over lines.
            if (sys%read_in%comp) then
                read (ir,*, iostat=ios) compint, i, a, j, b
                ! if complex will have complex formatting but sp_eigv should still be real.
                x=real(compint,p)
            else
                read (ir,*, iostat=ios) x, i, a, j, b
            end if

            if (ios == iostat_end) exit ! end of file
            if (ios /= 0) call stop_all('get_sp_eigv', 'Problem reading integrals file: '//trim(sys%read_in%fcidump))
            if (i > 0 .and. j == 0 .and. a == 0 .and. b == 0) then
                ! \epsilon_i -- temporarily store for all basis functions
                found_sp_eigv = .true.
                sp_eigv(i) = x
            else if (.not. found_sp_eigv) then
                ! Calculate single-particle eigenvalues according to
                ! \epsilon_i = h_ii + \sum_{j \in occ} (2 <ij|ij> - <ij|ji>)

                if (i == j .and. a == b .and. i == a .and. i > 0) then
                    ! <ii|ii>
                    if (i <= nocc) sp_eigv(i) = sp_eigv(i) + x
                else if (i == a .and. j == b .and. b > 0) then
                    ! <ij|ij>
                    if (.not. seen_ijij(i,j)) then
                        seen_ijij(i,j) = .true.
                        seen_ijij(j,i) = .true.
                        if (i <= nocc) sp_eigv(j) = sp_eigv(j) + 2*x
                        if (j <= nocc) sp_eigv(i) = sp_eigv(i) + 2*x
                    end if
                else if (((i == b .and. j == a) .or. (i == j .and. a == b)) .and. b > 0) then
                    ! <ij|ji>
                    if (.not. seen_ijji(i,a)) then
                        seen_ijji(i,a) = .true.
                        seen_ijji(a,i) = .true.
                        if (i <= nocc) sp_eigv(a) = sp_eigv(a) - x
                        if (a <= nocc) sp_eigv(i) = sp_eigv(i) - x
                    end if
                else if (i == a .and. j == 0 .and. b == 0 .and. i > 0) then
                    ! h_ii
                    sp_eigv(i) = sp_eigv(i) + x
                end if
            end if

        end do

        if (.not. found_sp_eigv) then
            ! Using Fock energies calculated from other integrals
            if (sys%read_in%uhf) call stop_all('get_sp_eigv', 'Calculation of single particle eigenvalues not implemented for UHF.')
            call warning('get_sp_eigv', 'Assuming orbitals are in energy order.  If not, calculated eigenvalues may be incorrect')
        end if

    end subroutine get_sp_eigv

    subroutine read_additional_exchange_integrals(sys, sp_fcidump_rank, verbose)

        ! For periodic bounary conditions we require additional integrals, to be read
        ! in from a separate FCIDUMP to be stored in sys%read_in%additional_exchange_ints{_imag}.
        !    sp_fcidump_rank: ranking array which converts index in the
        !         integrals file(s) to the (energy-ordered) index used in HANDE,
        !         i.e. sp_fcidump_rank(a) = i, where a is the a-th
        !         orbital according to the ordering used in the integral files
        !         and i is the i-th orbital by energy ordering.
        !         Note: must be 0-indexed and sp_fcidump_rank(0) = 0.  See above
        !         commments about this special case.

        use molecular_integrals, only: init_two_body_exchange_t, zero_two_body_exchange_int_store, &
                                       store_pbc_int_mol, broadcast_two_body_exchange_t
        use system, only: sys_t
        use errors, only: stop_all
        use parallel, only: parent, root

        use, intrinsic :: iso_fortran_env, only: iostat_end

        type(sys_t), intent(inout) :: sys
        integer, intent(in) :: sp_fcidump_rank(0:)

        logical, intent(in), optional :: verbose
        integer :: ir, ierr
        logical  :: t_exists
        integer :: i,j,a,b, ios
        real(p) :: x, y
        complex(p) :: compint
        integer :: rhf_fac

        ios = 0

        if (sys%read_in%uhf) then
            rhf_fac = 1
        else
            rhf_fac = 2  ! need to double count some integrals.
        end if

        call init_two_body_exchange_t(sys, sys%read_in%pg_sym%gamma_sym, .false., sys%read_in%additional_exchange_ints)
        call zero_two_body_exchange_int_store(sys%read_in%additional_exchange_ints)
        if (sys%read_in%comp) then
            call init_two_body_exchange_t(sys, sys%read_in%pg_sym%gamma_sym, .true., sys%read_in%additional_exchange_ints_imag)
            call zero_two_body_exchange_int_store(sys%read_in%additional_exchange_ints_imag)
        end if

        if (parent) then
            inquire(file=sys%read_in%ex_fcidump, exist=t_exists)
            if (.not.t_exists) call stop_all('read_in_integrals', 'FCIDUMP does not &
                                                               &exist:'//trim(sys%read_in%ex_fcidump))
            open (newunit=ir, file=sys%read_in%ex_fcidump, status='old', form='formatted')

            do
                if (sys%read_in%comp) then
                    read (ir,*, iostat=ios) compint, i, a, j, b
                    x=real(compint,p)
                    y=aimag(compint)
                else
                    read (ir,*, iostat=ios) x, i, a, j, b
                end if

                if (ios == iostat_end) exit
                if (ios /= 0) call stop_all('read_additional_exchange_integrals', &
                                            'Problem reading integrals file: '//trim(sys%read_in%ex_fcidump))

                if (.not. (i == b .or. a == j)) call stop_all('read_additional_exchange_integrals',&
                                        "Unexpected integral indexes encountered.")
                i = rhf_fac*sp_fcidump_rank(i)
                j = rhf_fac*sp_fcidump_rank(j)
                a = rhf_fac*sp_fcidump_rank(a)
                b = rhf_fac*sp_fcidump_rank(b)

                call store_pbc_int_mol(i,j,a,b,x,sys%basis%basis_fns, sys%read_in%additional_exchange_ints, ierr)
                if (sys%read_in%comp) then
                    call store_pbc_int_mol(i,j,a,b,y,sys%basis%basis_fns, sys%read_in%additional_exchange_ints_imag, ierr)
                end if
            end do
        end if

        call broadcast_two_body_exchange_t(sys%read_in%additional_exchange_ints, root)
        if (sys%read_in%comp) then
            call broadcast_two_body_exchange_t(sys%read_in%additional_exchange_ints_imag, root)
        end if

        call modify_one_body_ints(sys, sys%read_in%coulomb_integrals, sys%read_in%additional_exchange_ints, &
                                    sys%read_in%one_e_h_integrals)
        if (sys%read_in%comp) then
            call modify_one_body_ints(sys, sys%read_in%coulomb_integrals_imag, sys%read_in%additional_exchange_ints_imag, &
                                    sys%read_in%one_e_h_integrals_imag)
        end if

    end subroutine read_additional_exchange_integrals

    subroutine modify_one_body_ints(sys, two_e_ints, pbc_ex_ints, one_e_ints)

        ! These two expressions for the Hartree-Fock energy are made identical here:
        ! 1) E_HF = \sum_i <i|H|i> + \sum_{i<j} (<ij|ij> + <ij|ji>_exchange)
        ! 2) E_HF = \sum_i <i|H|i> + 1/2\sum_{i,j} (<ij|ij> + <ij|ji>_exchange)
        ! by including the expression +1/2\sum_{i} (<ii|ii> + <ii|ii>_exchange)
        ! into the one_body integrals.
        ! Note that this is necessary as <ii|ii> and <ii|ii>_exchange (may) differ (by cutoffs).

        ! In:
        !   sys: information on system being studied.
        !   two_e_ints: object storing coulomb integrals to be used in modification.
        !   pbc_ex_ints: object storing additional pbc ints.
        ! In/Out:
        !   one_e_ints: object containing one body integrals to be modified.

        ! NB this function uses separately passed objects for the different integrals
        ! to enable use of the same function for both the real and imaginary components
        ! of all integrals.

        use molecular_integrals, only: store_one_body_int, get_one_body_int_mol_nonzero, &
                               get_two_body_int_mol_nonzero, get_two_body_exchange_pbc_int_nonzero,&
                               pbc_ex_int_indx, int_ex_indx
        use system, only: sys_t
        use molecular_integral_types, only: two_body_t, one_body_t, two_body_exchange_t

        type(sys_t), intent(in) :: sys
        type(two_body_t), intent(in) :: two_e_ints
        type(two_body_exchange_t), intent(in) :: pbc_ex_ints
        type(one_body_t), intent(inout) :: one_e_ints
        real(p) :: intgrl
        integer :: i, ierr
        type(int_ex_indx) :: indx

        do i = 1, sys%basis%nbasis, 2
            indx = pbc_ex_int_indx(.false., i,i,i,i,sys%basis%basis_fns)
            intgrl = get_one_body_int_mol_nonzero(one_e_ints, i, i, sys%basis%basis_fns)

            intgrl = intgrl + 0.5_p * get_two_body_int_mol_nonzero(two_e_ints, i, i, i, i, sys%basis%basis_fns)
            intgrl = intgrl - 0.5_p * get_two_body_exchange_pbc_int_nonzero(pbc_ex_ints, i, i, i, i, sys%basis%basis_fns)

            call store_one_body_int(i, i, intgrl, sys, .false., one_e_ints, ierr)
        end do

    end subroutine modify_one_body_ints

end module read_in_system
