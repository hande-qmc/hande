module qmc_data

use const
use spawn_data, only: spawn_t, proc_map_t
use csr, only: csrp_t
use parallel, only: parallel_timing_t
use importance_sampling_data
use excit_gens, only: excit_gen_data_t
use reference_determinant, only: reference_t, reference_t_json
use dSFMT_interface, only: dSFMT_state_t

implicit none

! --- Enums for various modes (must be declared before use) ---

! Semi-stochastic projection/annihilation mode
! See comments in semi_stoch.F90 for more details.
enum, bind(c)
    ! Gather the entire set of amplitudes in the deterministic space onto each
    ! processor and perform the projection Hv distributed over rows of H.
    ! Newly spawned particles belong automatically to the processor that created
    ! them.
    enumerator :: semi_stoch_separate_annihilation
    ! Perform the projection Hv distributed over elements of v (ie determinants
    ! assigned to each processor) and distribute the spawned particles via the
    ! normal (stochastic projection) annihilation framework.
    enumerator :: semi_stoch_combined_annihilation
end enum

enum, bind(c)
    ! Explicitly renormalise excitation generators such that selecting the single
    ! excitation i->a such that i is only chosen if there exists an unoccipied a of the
    ! correct symmetry and the double excitation i,j->a,b such that given the choice of
    ! (i,j) a is only chosen if there exists an unoccupied b of the correct symmetry.
    enumerator :: excit_gen_renorm
    ! Similar to excit_gen_renorm but when selecting ij in a double excitation, first
    ! decide whether their spins are parallel or not. Based on an idea of Alavi et al.
    enumerator :: excit_gen_renorm_spin
    ! Don't require i (single) and i,j,a (double) to have allowed excitations.  This gives
    ! slightly less efficient excitation generation (negligible in large systems) but
    ! avoids an expensive renormalisation step to calculate the excitation generation
    ! probabilities.
    enumerator :: excit_gen_no_renorm
    ! Similar to excit_gen_no_renorm but when selecting ij in a double excitation, first
    ! decide whether their spins are parallel or not. Based on an idea of Alavi et al.
    enumerator :: excit_gen_no_renorm_spin
    ! Weight the excitations according to a Power-Pitzer limit on the bounds of the integrals
    ! The version O(M/64) which chooses occ orbitals first, and excites with probabilities akin 
    ! to that of the reference.
    enumerator :: excit_gen_power_pitzer
    ! The version O(M) which chooses occ orbitals first. ij are found uniformly.
    enumerator :: excit_gen_power_pitzer_occ
    ! The version O(M) which chooses occ orbitals first. ij are found with heat bath.
    enumerator :: excit_gen_power_pitzer_occ_ij
    ! The version O(N) which precomputes more than excit_gen_power_pitzer.
    enumerator :: excit_gen_power_pitzer_orderN
    ! The Cauchy Schwarz version O(M) which chooses occ orbitals first. ij are found uniformly.
    enumerator :: excit_gen_cauchy_schwarz_occ
    ! The Cauchy Schwarz version O(M) which chooses occ orbitals first. ij are found with heat bath.
    enumerator :: excit_gen_cauchy_schwarz_occ_ij
    ! Heat bath excitation generators, based on Holmes, A. A.; Changlani, H. J.; Umrigar, 
    ! C. J. J. Chem. Theory Comput. 2016, 12, 1561â€“1571
    enumerator :: excit_gen_heat_bath
    ! Finds single excitations uniformly, like renorm
    enumerator :: excit_gen_heat_bath_uniform
    ! Finds single excitations with exact weights.
    enumerator :: excit_gen_heat_bath_single
end enum

! Types of semi-stochastic space.
enum, bind(c)
    ! This option uses an empty deterministic space, and so turns
    ! semi-stochastic off.
    enumerator :: empty_determ_space = 0
    ! This space is generated by choosing the determinants with the highest
    ! populations in the main walker list, at the point the deterministic space
    ! is generated.
    enumerator :: high_pop_determ_space
    ! This option generates the deterministic space by reading the states in
    ! from an HDF5 file (named SEMI.STOCH.*.H5).
    enumerator :: read_determ_space
    ! This option tells the semi-stochastic initialisation routine to use a
    ! deterministic space which has already been created, and which should
    ! be stored in the dets array within the semi_stoch_t instance on input.
    enumerator :: reuse_determ_space
    ! This option means we use a generated deterministic space from a (truncated)
    ! CI space.
    enumerator :: ci_determ_space
end enum

enum, bind(c)
    ! Numerator of the final expression for the projected energy. i.e. \sum H_0j
    ! N_j.
    enumerator :: dt_numerator = 1
    ! Denominator of the final expression for the projected energy. i.e.
    ! reference population.
    enumerator :: dt_denominator
    ! Shift.
    enumerator :: dt_shift
    ! Projected energy calculated from the ratio of dt_numerator and
    ! dt_denominator.
    enumerator :: dt_proj_energy
end enum

enum, bind(c)
    ! We have not attempted any optimisation of the shift damping.
    enumerator :: sd_no_optimisation = -2
    ! The shift damping has been previous optimised.
    enumerator :: sd_optimised = -1
    ! We have accumulated information and should now attempt to optimise the shift damping.
    enumerator :: sd_optimising = 0
    ! We need to wait one blocking cycle before attempting optimisation.
    enumerator :: sd_wait1 = 1
    ! We need to wait two blocking cycles before attempting optimisation.
    enumerator :: sd_wait2 = 2
end enum

! --- QMC input ---

type qmc_in_t

    ! Seed used to initialise the dSFMT random number generator.
    integer :: seed

    ! True if allowing non-integer values for psip populations.
    logical :: real_amplitudes = .false.
    ! Force the fractional part of the population to have the same precision
    ! as used when POP_SIZE=32.
    logical :: real_amplitude_force_32 = .false.
    ! The minimum amplitude of a spawning event which can be added to
    ! the spawned list.
    ! If real amplitudes are not used then the following default will be
    ! overwritten by 0.0_p. In this case it will effectively not be used and all
    ! spawnings events will be integers.
    real(p) :: spawn_cutoff = 0.01_p

    ! Selection of excitation generator to use.  One of the excit_gen_* enum.
    integer :: excit_gen = excit_gen_renorm

    ! probability of attempting single or double excitations...
    ! set to be nonsense value so can easily detect if it's given as an input option
    real(p) :: pattempt_single = -1, pattempt_double = -1
    ! True if pattempt_single/pattempt_double should be varied until shift starts to vary.
    ! They are varied in an attempt to make the means of |Hij|/pgen be the same for singles and doubles.
    ! Only used for excitation generators using pattempt_single/pattempt_double.
    ! If shift has already started varying, ignore pattempt_update.
    ! [todo] - check whether restarting works correctly with pattempt_update
    logical :: pattempt_update = .false.
    ! If true and restarting, accumulated data to vary pattempt_single/double is reset.
    ! If not restarting, this will not have any effect.
    logical :: pattempt_zero_accum_data = .false.
    ! probability of selecting ij to be parallel. Used in no_renorm_spin, renorm_spin
    ! excitation generators.
    ! set to a nonsense value so we can easily detect if it's given as an input option.
    real(p) :: pattempt_parallel = -1

    ! timestep
    ! Note: qmc_state_t%tau is used and (if desired) updated during the course of a simulation)
    real(p) :: tau
    ! Are we doing a timestep search
    logical :: tau_search = .false.

    ! The shift (energy offset) is set to vary_shift_from when variable shift mode is entered.
    ! WARNING: if both initial_shift and vary_shift_from are set, then we expect the
    ! user to have been sensible.
    real(p) :: vary_shift_from = 0.0_p
    ! If true, then the when variable shift mode is entered the shift is set to be the
    ! current projected energy estimator.  Overrides vary_shift_from.
    logical :: vary_shift_from_proje = .false.
    ! Initial shift.
    real(p) :: initial_shift = 0.0_p
    ! Factor by which the changes in the population are damped when updating the
    ! shift. Used to set initial value within qmc_state_t.
    real(p) :: shift_damping = huge(1.0_p) 
    ! Restoring force factor in the harmonic damping model from Yang, Pahl and
    ! Brand (J. Chem. Phys. 153, 174103 (2020) (DOI:10.1063/5.0023088)) 
    ! used to direct the walker population to the given
    ! target population. The original population dynamics are obtained if set
    ! equal to zero. Sets default value within qmc_state_t. 
    real(p) :: shift_harmonic_forcing = 0.0_p
    ! If true, the shift_harmonic_forcing term will be set equal to the square
    ! of the shift_damping term divided by 4 to obtain critial damping.  
    logical :: shift_harmonic_crit_damp = .false.

    logical :: vary_shift
    logical :: vary_shift_present = .false.

    ! Array sizes: main and spawned particle lists.
    ! If these are < 0, then the values represent the number of MB to be used.
    ! CARE: as we don't modify qmc_in_t objects, one should inspect the sizes
    ! used in particle_t and spawned_particle_t for the exact values used (which may
    ! be rounded for various reasons).
    integer :: walker_length = 0
    integer :: spawned_walker_length = 0

    ! The initial population on the reference determinant/trace of the density matrix.
    ! Overridden by a restart file.
    real(p) :: D0_population = 0
    ! Number of particles before which varyshift mode is turned on.
    real(p) :: target_particles = huge(1.0_p)
    ! Whether target_particles refers to the total population or to the reference.
    logical :: target_reference = .false.

    ! Using the initiator approximation?
    logical :: initiator_approx = .false.
    ! Population above which a determinant is an initiator.
    real(p) :: initiator_pop = 3.0_p

    ! number of monte carlo cycles/report loop
    integer :: ncycles
    ! number of report cycles
    ! the shift is updated and the calculation information printed out
    ! at the end of each report cycle.
    integer :: nreport

    ! If true then allow the use of MPI barrier calls.
    logical :: use_mpi_barriers = .false.

    ! The minimum ratio over number of orbitals of individual weight over total weight when using the
    ! occref power pitzer excitation generator.
    real(p) :: power_pitzer_min_weight = 0.01_p

    ! If true, use a quasiNewton step
    logical :: quasi_newton = .false.

    ! The lower threshold for a quasiNewton enegy difference
    ! Set to non sensible value by default so it is easily detectable if user did not specify it.
    ! The value is approximated by HOMO-LUMO gap unless user overwrites it.
    real(p) :: quasi_newton_threshold = -1.0_p

    ! The value to set the quasiNewton energy difference to if lower than the
    ! threshold
    real(p) :: quasi_newton_value = -1.0_p

    ! In death step when using QuasiNewton, scale the difference of inst. projected energy and shift
    ! by time step times quasi_newton_pop_control in equilibrium, zero before shift varies.
    ! Set to 1 if not using quasiNewton.
    real(p) :: quasi_newton_pop_control = -1.0_p

end type qmc_in_t

type fciqmc_in_t

    ! How often do we change the reference determinant to the determinant with
    ! greatest population?
    ! Default: we don't.
    integer :: select_ref_det_every_nreports = huge(1)

    ! Also start with D0_population on i_s|D_0>, where i_s is the spin-version
    ! operator.  This is only done if no restart file is used *and* |D_0> is not
    ! a closed shell determinant.
    logical :: init_spin_inv_D0 = .false.

    ! Factor by which the population on a determinant must exceed the reference
    ! determinant's population in order to be accepted as the new reference
    ! determinant.
    real(p) :: ref_det_factor = 1.50_p

    ! Flag for using non-blocking communications.
    ! Default: False.
    logical :: non_blocking_comm = .false.
    ! Flag for using load balancing.
    ! Default: False.
    logical :: doing_load_balancing = .false.

    ! Importance sampling (see enumerator in importance_sampling_data for allowed
    ! values).  Currently only relevant to the Heisenberg model.  trial_function
    ! will always be single_basis for other models to represent a single determinant.
    integer :: trial_function = single_basis
    ! If we are not using importance sampling, this is set to no_guiding, otherwise
    ! to a specific enumerator in importance_sampling_data to specify the corresponding
    ! guiding function being used.
    integer :: guiding_function = no_guiding

    ! How to apply the initiator approximation in complex spaces.
    logical :: quadrature_initiator = .true.

    ! Evolve two copies of the wavefunction to enable unbiased sampling of the RDM
    logical :: replica_tricks = .false.

    ! Stochastically sample the two-body reduced density matrix.
    logical :: density_matrices = .false.

    ! Filename to write density matrix to
    character(255) :: density_matrix_file = 'RDM'

end type fciqmc_in_t

type semi_stoch_in_t
    ! The iteration on which to turn on the semi-stochastic algorithm using the
    ! deterministic space specified by space_type.
    integer :: start_iter = 1
    ! The iteration on which to turn on the semi-stochastic algorithm, relative
    ! to the iteration that the shift starts to vary (or the iteration at which
    ! all shifts have started to vary, in the case of multiple replicas).
    integer :: shift_iter = -1
    ! space_type is used to tell the semi-stochastic initialisation routine
    ! which type of deterministic space to use. See the 'determ-space' parameters
    ! defined in semi_stoch.F90 for the various values it can take.
    integer :: space_type = empty_determ_space
    ! Certain deterministic space types need a target size to be input to tell the
    ! semi-stochastic initialisation routine how many states to try and include. In
    ! such cases this variable should be set on input.
    integer :: target_size = 0
    ! If true then the deterministic states will be written to a file.
    logical :: write_determ_space = .false.
    ! Algorithm used for projection/annihilation in the deterministic subspace.
    ! Only the values given by semi_stoch_*_annihilation (see enum above) are permitted.
    integer :: projection_mode = semi_stoch_separate_annihilation
    ! If creating the deterministic space by reading a SEMI.STOCH.x.H5 file,
    ! then this integer gives the id (x) of the file to read.
    ! If unset (==huge(0)) then the lowest used id will be searched for.
    integer :: read_id = huge(0)
    ! If writing the deterministic space to a SEMI.STOCH.x.H5 file, then this
    ! integer gives the id (x) of the file to be written to.
    ! If unset (==huge(0)) then the lowest unused id will be searched for.
    integer :: write_id = huge(0)
    ! Description of CI space used to generate the deterministic space if
    ! space_type == ci_determ_space.
    ! Only ref%ex_level and ref%occ_list are used.
    type(reference_t) :: ci_space
end type semi_stoch_in_t

type ccmc_in_t
    ! How frequently (in log_2) an excitor can be moved to a different processor.
    ! See comments in spawn_t and assign_particle_processor.
    integer :: move_freq = 5
    ! Value of cluster%amplitude/cluster%pselect above which spawns are split up
    ! The default value corresponds to off.
    real(p) :: cluster_multispawn_threshold = huge(1.0_p)
    ! Use the full non-composite algorithm?
    logical :: full_nc = .false.
    ! Sample only linked clusters in CCMC?
    logical :: linked = .false.
    ! If true, vary shift to control reference, not total, population
    logical :: vary_shift_reference = .false.
    ! Calculate the (unrelaxed) density matrices?
    logical :: density_matrices = .false.
    ! Filename to write density matrix to
    character(255) :: density_matrix_file = 'RDM'
    ! Whether to use even cluster selection approach.
    logical :: even_selection = .false.
    ! Whether to use a secondary reference.
    logical :: multiref = .false.
    ! Number of additional references to use.
    integer :: n_secondary_ref = 0
    ! The secondary references.
    type(reference_t), allocatable :: secondary_refs(:)
    ! Acceptance algorithm for mrcc excitations.
    integer :: mr_acceptance_search
    ! Name of the file containing secondary references (only if mr_read_in is true).
    character(255) :: mr_secref_file
    ! CC level from every secondary reference.
    integer :: mr_excit_lvl = -1
    ! Number of frozen electrons to add to the secondary references.
    integer :: mr_n_frozen = 0
    ! Whether to read in a secondary reference file.
    logical :: mr_read_in = .false.
end type ccmc_in_t

type restart_in_t
    ! Restart calculation from file.
    logical :: read_restart = .false.
    ! Index to read from (huge indicates not set).
    integer :: read_id = huge(0)
    ! Print out restart file.
    logical :: write_restart = .false.
    ! Index to write to (huge indicates not set).
    integer :: write_id = huge(0)
    ! Print out restart file every X reports (in addition to at the end).
    integer :: write_freq = huge(0)
    ! Print out a restart file just before the shift turns on.
    logical :: write_restart_shift = .false.
    ! Index to write to (huge indicates not set).
    integer :: write_shift_id = huge(0)
    ! Restart the RNG state (if possible) from the previous calculation?
    logical :: restart_rng = .true.
end type restart_in_t

type output_in_t
    ! Filename to direct all calculation output to. If set to 'stdout'
    ! will be returned to standard output pipe.
    character(255) :: out_filename = 'stdout'
    ! Whether to reproduce system initialisation information at start
    ! of calculation output file (if not to stout).
    logical :: reprint_sys_info = .true.
end type output_in_t

type blocking_in_t
    ! Enable blocking on the fly.
    logical :: blocking_on_the_fly = .false.
    ! log2 of the frequency at which the start point is saved. If
    ! negative, the default value is used. Default is the nearest integer to the
    ! log2(nreports) - 8, assuming this is greater than 1, or otherwise no start
    ! points being saved.
    integer :: start_save_frequency = -1
    ! Number of start points that is to be saved. If negative, the default value
    ! is used. The default is the integer part of nreports/2^(start_save_frequency).
    ! If this becomes greater than 1, we will instead save no start points (same
    ! edge case as 0 < start_save_freq < 1.
    integer :: start_point_number = -1
    ! Name blocking on the fly output file.
    character(255) :: filename = 'BLOCKING'
    ! The number of iteration from which the data for blocking analysis is
    ! collected. If negative, the default value is used. Default is to start
    ! collecting data once vary_shift is true.
    integer :: start_point = -1
    ! Limit of the sum of error in error and standard deviation of projected
    ! energy. If this value is reached calculation is terminated. Default = 0
    real(p) :: error_limit = 0
    ! The minimum number of optimal block lengths required for a calculation to
    ! terminate. The calculation will not terminate due to the standard error
    ! falling below error_limit until at least this number of optimal
    ! reblock lengths are included within the calculation. This ensures that
    ! our error estimate is reliable at termination.
    integer :: min_blocks_used = 10
    ! The lower limit of the number_of_blocks used to terminate the calculation.
    ! The calculation is terminated if this condition is met irrelevant of
    ! the standard error of the projected energy. Default = (huge)
    integer :: blocks_used = huge(0)
    ! Enable automatic optimisation of the shift damping using the standard
    ! deviations of the shift and projected energy distributions.
    logical :: auto_shift_damping = .false.
    ! Ratio that defines strictness of automatic shift damping optimisation.
    real(p) :: shift_damping_precision = 2.0_p
    ! Force shift damping optmisation when we've already performed one. For
    ! use when restarting from previously optimised calculation.
    logical :: force_shift_damping_opt = .false.
end type

! --- Parallel info ---

! Combine information required for non-blocking report loop quantities
! into one type for convenience.
type nb_rep_t
    ! Array to store report loop estimators such as projected energy
    ! etc.
    ! This array must not be deallocated, copied or inspected in any
    ! way in between report loop communication.
    real(dp), allocatable :: rep_info(:)
    ! Array whose entries will contain:
    ! 1. The total number of spawned walkers in a given report loop
    !    which is to be used for calculating the spawning rate.
    ! 2. The number of walkers spawned from a given processor
    !    to all other processors except the current one, which
    !    is used for calculating the total number of walkers for a given
    !    report loop.
    integer :: nb_spawn(2)
    ! Array of requests used for non blocking communications.
    ! This array must not be deallocated, copied or inspected in any
    ! way in between report loop communication. request(nprocs)
    integer, allocatable :: request(:)
end type nb_rep_t

type load_bal_in_t
    ! Number of slots walker lists are initially subdivided into for proc_map
    ! Default = 1 unless using load balancing (in which case 20).
    ! Input option: load_balancing_slots
    integer :: nslots = 1
    ! Population which must be reached before load balancing is attempted.
    ! Default = 1000.
    ! Input option: load_balancing_pop
    integer(int_64) :: pop = 1000
    ! Percentage load imbalance we aim to achieve when performing load balancing.
    ! i.e. min_pop = (1-percent_imbal)*av_pop, max_pop = (1+percent_imbal)*av_pop.
    ! Default = 0.05
    ! Input option: percent_imbal
    real(p) :: percent = 0.05
    ! Maximum number of load balancing attempts.
    ! Default = 2.
    ! Input option: max_load_attempts
    integer :: max_attempts = 2
    ! Write load balancing information every time load balancing is attempted.
    ! Input option: write_load_info
    logical :: write_info = .false.
end type load_bal_in_t

type load_bal_state_t
    ! Tag to check which stage if load balancing is required. This is reset to false
    ! once redistribution of determinants has taken place to ensure load balancing
    ! occurs once during a report loop.
    logical :: needed = .false.
    ! Current number of load balancing attempts.
    integer :: nattempts = 0
    type(proc_map_t) :: proc_map
end type load_bal_state_t

type parallel_t
    ! Type containing information on current state of load imbalance of
    ! particles, including proc_map.
    type(load_bal_state_t) :: load
    ! Type containing arrays necessary for report communication when using
    ! non-blocking communications.
    type(nb_rep_t) :: report_comm
end type parallel_t

! --- semi-stochastic ---

! Array to hold the indices of deterministic states in the dets array, accessed
! by calculating a hash value. This type is used by the semi_stoch_t type and
! is intended only to be used by this object.
type determ_hash_t
    ! For an example of how to use this type to see if a determinant is in the
    ! deterministic space or not, see the routine check_if_determ.

    !rSeed used in the MurmurHash function to calculate hash values.
    integer :: seed
    ! The size of the hash table (ignoring collisions).
    integer :: nhash
    ! The indicies of the determinants in the semi_stoch_t%dets array.
    ! Note that element nhash+1 should be set equal to determ%tot_size+1.
    ! This helps with avoiding out-of-bounds errors when using this object.
    integer, allocatable :: ind(:) ! (semi_stoch_t%tot_size)
    ! hash_ptr(i) stores the index of the first index in the array ind which
    ! corresponds to a determinant with hash value i.
    ! This is similar to what is done in the CSR sparse matrix type (see
    ! csr.f90).
    integer, allocatable :: hash_ptr(:) ! (nhash+1)
end type determ_hash_t

type semi_stoch_t
    ! True if a semi-stochastic calculation is being performed with this object.
    logical :: doing_semi_stoch = .false.
    ! Algorithm used for projection/annihilation in the deterministic subspace.
    ! Only the values given by semi_stoch_*_annihilation (see enum above) are permitted.
    integer :: projection_mode = semi_stoch_combined_annihilation
    ! Integer to specify which type of deterministic space is being used.
    ! See the various determ_space parameters defined above.
    integer :: space_type = empty_determ_space
    ! The total number of deterministic states on all processes.
    integer :: tot_size = 0
    ! sizes(i) holds the number of deterministic states belonging to process i.
    integer, allocatable :: sizes(:) ! (0:nproc-1)
    ! The Hamiltonian in the deterministic space, stored in a sparse CSR form.
    ! An Hamiltonian element, H_{ij}, is stored in hamil if and only if both
    ! i and j are in the deterministic space.
    type(csrp_t) :: hamil
    ! This array is used to store the values of amplitudes of deterministic
    ! states throughout a QMC calculation.
    real(p), allocatable :: vector(:,:) ! (nspaces,sizes(iproc))
    ! If separate_annihilation is true, then an extra MPI call is used to join
    ! together the the deterministic vector arrays from each process. This
    ! array is used to hold the results, which will be the list of all
    ! deterministic amplitudes.
    ! If separate_annihilation is not true then this array will remain
    ! deallocated.
    real(p), allocatable :: full_vector(:,:) ! (nspaces,tot_size)
    ! For the quasi_newton approach, each determinant in the deterministic space
    ! takes a weight for being spawned to.  This is included in the Hamiltonian
    ! directly, but must also be used when modifying the shift.  rho-w_i is stored
    ! for all determinants on this processor in the deterministic space.
    ! Note that rho is propagator%quasi_newton_pop_control.
    real(p), allocatable :: rho_minus_qn_weight(:) ! sizes(iproc)
    ! If separate_annihilation is true then this array will hold the indices
    ! of the deterministic states in the main list. This prevents having to
    ! search the whole of the main list for the deterministic states.
    ! If separate_annihilation is not true then this array will remain
    ! deallocated.
    integer, allocatable :: indices(:) ! sizes(iproc)
    ! dets stores the deterministic states across all processes.
    ! All states on process 0 are stored first, then process 1, etc...
    integer(i0), allocatable :: dets(:,:) ! (string_len, tot_size)
    ! A hash table which allows the index of a determinant in dets to be found.
    ! This is done by calculating the hash value of the given determinant.
    type(determ_hash_t) :: hash_table
    ! Deterministic flags of states in the main list. If determ_flags(i) is
    ! equal to 0 then the corresponding state in position i of the main list is
    ! a deterministic state, else it is not.
    integer, allocatable :: flags(:)
    ! Type for holding information about semi-stochastic MPI timings.
    ! This is only used if separate_annihilation is .true.. If it is false
    ! then semi-stochastic communication is performed with the main spawning
    ! communicaton.
    type(parallel_timing_t) :: mpi_time
end type semi_stoch_t

! --- Estimators ---

type particle_t
    ! Current number of walkers stored in the main list (processor dependent).
    ! This is updated during annihilation and merging of the spawned walkers into
    ! the main list.
    integer :: nstates 
    ! Total number of particles on all walkers/determinants (processor dependent)
    ! Updated during death and annihilation and merging.
    ! The first element is the number of normal (Hamiltonian) particles.
    ! Subsequent elements are the number of Hellmann--Feynamnn particles.
    real(dp), allocatable :: nparticles(:) ! (sampling_size)
    ! Total number of particles across *all* processors, i.e. \sum_{proc} nparticles_{proc}
    real(dp), allocatable :: tot_nparticles(:) ! (sampling_size)
    ! Total number of particles on all determinants for each processor
    real(dp), allocatable :: nparticles_proc(:,:) ! (sampling_size,nprocs)
    ! Walker information: main list.
    ! sampling_size is one for each quantity sampled (i.e. 1 for standard
    ! FCIQMC/initiator-FCIQMC, 2 for FCIQMC+Hellmann--Feynman sampling or
    ! complex FCIQMC/CCMC/DMQMC).
    integer :: nspaces = 1
    ! number of additional elements stored for each determinant in dat for
    ! (e.g.) importance sampling.
    integer :: info_size = 0
    ! Amplitudes can be integers or floats.  They are stored as integers using
    ! fixed precision and encoded by multiplying by pop_real_factor (with some
    ! stochastic rounding to account for the resolution of the fixed precision)
    ! and decoded by dividing by pop_real_factor.  In principle this could be done
    ! with bit shifts and care over the sign...
    integer(int_p) :: pop_real_factor
    ! a) determinants
    integer(i0), allocatable :: states(:,:) ! (string_len, walker_length)
    ! [todo] - nicer referencing for elements of dat and ! pops
    ! b) walker population
    ! NOTE:
    !   When using the real_amplitudes option, pops stores encoded
    !   representations of the true walker populations. To convert
    !   pops(:,i) to the actual population on determinant i, one must
    !   take real(pops(:,i),p)/real_factor. Thus, the resolution
    !   in the true walker populations is 1/real_factor. This is how
    !   non-integers populations are implemented. When not using the real_amplitudes
    !   option, real_factor will be equal to 1, allowing only integer
    !   populations. In general, when one sees that a integer is of kind int_p, it
    !   should be understood that it stores a population in its encoded form.
    integer(int_p), allocatable :: pops(:,:) ! (nspaces,walker_length)
    ! c) Walker information.  This contains:
    ! * Diagonal matrix elements, K_ii.  Storing them avoids recalculation.
    !   K_ii = < D_i | H | D_i > - E_0, where E_0 = <D_0 | H | D_0> and |D_0> 
    !   is the reference determinant.
    ! * If we're doing Hellmann--Feynmann sampling, matrix elements for the
    !   1-body operator's diagonal is in 2:sampling_size elements.
    ! * Further data in sampling_size+1:sampling_size+info_size. For example, when
    !   calculating the projected energy with various trial wavefunctions, it is
    !   useful to store quantites which are expensive to calculate and which are
    !   instead of recalculating them. For the Neel singlet state, the first component
    !   gives the total number of spins up on the first sublattice. The second
    !   component gives the number of 0-1 bonds where the 1 is on the first
    !   sublattice.
    real(p), allocatable :: dat(:,:) ! (sampling_size+info_size,walker_length)
    ! This variable will become equal to true if we ever run out of memory in
    ! particle lists, in which case the program will exit at the next
    ! opportunity.
    logical :: error = .false.
    ! Set to false once a memory warning has been printed to prevent multiple warning messages.
    logical :: warn = .true.
    ! Number of memory warnings
    integer :: warning_count = 0
end type particle_t

type spawned_particle_t
    ! List of spawned particles.
    type(spawn_t) :: spawn
    ! List of spawned particles received from other processors.  Used for non-blocking
    ! communications (normal synchronous communications can just use spawn alone).
    type(spawn_t) :: spawn_recv
    ! Rate of spawning.  This is a running total over MC cycles on each processor
    ! until it is summed over processors and averaged over cycles in
    ! update_energy_estimators.
    real(p) :: rspawn = 0.0_p
end type spawned_particle_t

type reblock_data_t
    ! Data type containing the information for the main array used for reblock
    ! analysis. The information contained in this data type is for a given block
    ! size.

    ! Number of blocks of a given block size.
    integer :: n_blocks = 0
    ! Sums of data are saved here until sufficient size is reached.
    real(p) :: data_accumulator = 0.0_p
    ! Sums of data of a given block size.
    real(p) :: sum_of_blocks = 0.0_p
    ! Sums of squares of data of a give block size.
    real(p) :: sum_of_block_squares = 0.0_p

end type reblock_data_t

type blocking_t
    ! Log_2 of maximum block size.
    integer :: lg_max = 0
    ! Number of start points to start reblocking from.
    integer :: n_saved_startpoints = 0
    ! Frequency at which the data for the start point is saved. In terms of the number of reports
    integer(int_64) :: save_fq = 0_int_64
    ! Number of report cycles from the start of all blocking to the current cycle.
    integer(int_64) :: n_reports_blocked = 0_int_64
    ! reblock_data_t type array with reblock_data(datatype, log_2(block_size).
    ! datatypes are dt_numerator, dt_denominator, dt_shift, dt_proj_energy (see
    ! enum above).
    type(reblock_data_t), allocatable :: reblock_data(:,:)
    ! Product between dt_numerator and dt_denominator for different block sizes.
    ! data_product(log_2(block_size)).
    real(p), allocatable :: data_product(:)
    ! Arrays for calculation of optimal mean and standard deviation at different
    ! start points. reblock_data and data_product are temporarily copied before
    ! the calculation on them is carried out.
    type(reblock_data_t), allocatable :: reblock_data_2(:,:)
    real(p), allocatable :: data_product_2(:)
    ! Arrays containing the mean, standard deviation and covariance of all block
    ! sizes
    ! block_mean(datatype, log2(blocksize)) = mean of different block sizes of
    ! datatype.
    ! block_std(datatype, log2(blocksize)) = standard deviation of different
    ! block sizes of datatype.
    ! block_cov(log2(blocksize)) = covariance of the two data types of different
    ! block sizes.
    ! datatypes are dt_numerator, dt_denominator, dt_shift, dt_proj_energy (see
    ! enum above).
    real(p), allocatable :: block_mean(:,:), block_std(:,:), block_cov(:)
    ! Optimal block is the smallest block that satisfies the condition
    ! B^3 > 2*(B*(number of blocks)) * (std(B)/std(0)) ^ 4, where B is the blocksize
    ! (number of data points in a block).
    ! optimal_mean(datatype) = block_mean of the block with the optimal block
    ! size for the datatype. For projected energy, the block size that is
    ! larger between dt_numerator and dt_denominator (see enum above) is used.
    real(p) :: optimal_mean(4) = 0.0_p
    ! Optimal block is the smallest block that satisfies the condition
    ! B^3 > 2*(B*(number of blocks)) * (std(B)/std(0)) ^ 4
    ! optimal_std(data_type) = block_std of the block with the optimal block
    ! size for the datatype. For projected energy, the block size that is
    ! larger between dt_numerator and dt_denominator (see enum above) is used.
    real(p) :: optimal_std(4) = 0.0_p
    ! Error in standard deviation calculated assuming that the blocks are normally
    ! distributed from central limit theorm. 1/(sqrt(2*(number of blocks - 1)))
    ! optimal_err(datatype) = Error in standard deviation of datatype.
    ! See enum above for datatypes.
    real(p) :: optimal_err(4) = 0.0_p
    ! Report number from which the data for reblocking is collected.
    integer :: start_ireport = -1
    ! Arrays for saving the data for reblocking for the purpose of starting the
    ! reblock from a different start position in the middle of a calculation.
    ! The frequency and the number of reblock_data and data_product arrays saved
    ! is determined by n_saved_startpoints and save_fq.
    ! reblock_save(:,:,start_point) = copy of reblock_data at the report
    ! cycle (start_point * save_fq).
    ! product_save(:,start_point) = copy of data_product at the report cycle
    ! (start_point * save_fq).
    type(reblock_data_t), allocatable :: reblock_save(:,:,:)
    real(p), allocatable :: product_save(:,:)
    ! (start_point*save_fq) indicates the number of reports from which the reblock analysis
    ! is started from. This is varied during the calculation to minimise the
    ! fractional error weighted by the 1/sqrt(number of data points)
    integer :: start_point = 0
    ! Array containing the different values of fractional error weighted by the
    ! 1/sqrt(number of data points) for each of the possible start positions.
    real(p), allocatable :: err_compare(:,:)
    ! log_2(block_size) of the optimal block sizes for different datatypes
    ! excluding dt_proj_energy. (see enum above)
    integer :: optimal_size(3) = 1
    ! Number of saved reblock_data type arrays at a given iteration.
    integer :: n_saved = 1
    ! Optimal blocksize saved for the calculation of number of blocks used.
    integer :: opt_bl_size=0
    ! Number of times we've increased the shift damping during calculation. This is to avoid
    ! the shift damping becoming too large for a stable calculation.
    integer :: n_increased_damping = 0
    ! We need a logical flag to tell us when we need to communicate to non-parent processes
    ! that reblocking has started. We can detect this on other processes (start_ireport < 0
    ! and we've started varying the shift) but on the parent processor have no such luck.
    logical :: first_iteration = .false.
    ! Ratio that defines strictness of automatic shift damping optimisation.
    real(p) :: shift_damping_precision
end type blocking_t

type estimators_t
    ! Population of walkers on reference determinant/trace of density matrix.
    ! [review] - JSS: This comment seems somewhat out of place and unclear.
    ! [reply] - VAN: I look here for information on D0_population etc. Where else do
    ! [reply] - VAN: you want me to put the relationship of D0_population and D0_population_comp?
    ! Comment for developers:
    ! Note that when using complex populations, the estimators array of D0_population
    ! can be (a,b,0,0) (as in the case for nspaces = 4, e.g. fciqmc complex and replica tricks),
    ! whereas real(D0_population_comp) would then be (a,a,b,b) for some floating point numbers a
    ! and b. Due to this mapping that is not one-to-one, using *_comp variables in non complex
    ! calculations and vice versa is dangerous and should not be done.
    real(p) :: D0_population = 0.0_p
    ! Population of walkers on reference determinant/trace of density matrix at previous timestep.
    real(p) :: D0_population_old = 0.0_p
    ! projected energy
    ! This stores during an FCIQMC report loop
    !   \sum_{i/=0} <D_0|H|D_i> N_i
    ! where D_0 is the reference determinants and N_i is the walker population on
    ! determinant D_i.
    ! The projected energy is given as
    !   <D_0|H|D_0> + \sum_{i/=0} <D_0|H|D_i> N_i/N_0
    ! and so proj_energy must be 'normalised' and averaged over the report loops
    ! accordingly.
    ! See comment for developers above for D0_population which holds similary for proj_energy.
    real(p) :: proj_energy = 0.0_p
    ! The instantaneous projected energy of the previous iteration is required for
    ! various purposes.
    real(p) :: proj_energy_old = 0.0_p
    ! Total number of occupied states across all processors.
    integer :: tot_nstates = 0
    ! The total number of successful spawning events, across all processors.
    integer :: tot_nspawn_events = 0

    ! If performing calculations with real and imaginary walkers must be able to
    ! accumulate complex values. When broadcasting between processors within
    ! update_energy_estimators these are each converted into two real values, then
    ! back to a complex value. When performing complex calculations this value
    ! can be freely updated except when within update_energy_estimators, where
    ! extra care must be taken.
    complex(p) :: proj_energy_comp = (0.0_p, 0.0_p)
    complex(p) :: D0_population_comp = (0.0_p, 0.0_p)

    ! Energy calculated from the RDM
    real(p) :: rdm_energy = 0.0_p
    real(p) :: rdm_trace = 0.0_p

    ! Hellmann--Feynman sampling (several terms must be accumulated and averaged separately):
    ! Signed population of Hellmann--Feynman particles
    !     \sum_i sign(N_i) \tilde{N}_i,
    ! where
    !     N_i is the Hamiltonian population on |D_i>,
    !     \tilde{N}_i is the Hellmann--Feynman population on |D_i>.
    real(dp) :: hf_signed_pop
    ! Population on the reference in the Hellmann--Feynman space, \tilde{N}_0.
    real(p) :: D0_hf_population
    ! \sum_i <D_0|O|D_i> N_i.
    real(p) :: proj_hf_O_hpsip
    ! \sum_i <D_0|H|D_i> \tilde{N}_i.
    real(p) :: proj_hf_H_hfpsip
    ! The total number of attempts made to select cluster from current distribution, across all
    ! processes.
    integer(int_64) :: nattempts = 0_int_64
end type estimators_t

type propagator_t
    ! If true, use a quasiNewton step
    logical :: quasi_newton = .false.
    ! The lower threshold for a quasiNewton enegy difference
    ! This default is never used except for printing qmc JSON data when not doing quasi newton.
    real(p) :: quasi_newton_threshold = 0_p
    ! The value to set the quasiNewton energy difference to if lower than the
    ! threshold
    real(p) :: quasi_newton_value
    ! This stores the Fock expectation value <i|f|i> which is equal to sp_eigv in read_in systems.
    ! In the 3D UEG this includes the exchange and Madelung terms.
    ! In other model systems, including the 2D UEG, this is just equal to sp_eigv for now.
    real(p), allocatable :: sp_fock(:) ! (sys%basis%nbasis)
    ! In death step when using QuasiNewton, scale the difference of inst. projected energy and shift
    ! by time step times quasi_newton_pop_control in equilibrium, zero before shift varies.
    ! Set to 1 if not using quasiNewton.
    real(p) :: quasi_newton_pop_control
end type propagator_t

type qmc_state_t
    ! When performing dmqmc calculations, dmqmc_factor = 2.0. This factor is
    ! required because in DMQMC calculations, instead of spawning from one end with
    ! the full probability, we spawn from two different ends with half probability each.
    ! Hence, tau is set to tau/2 in DMQMC calculations, so that an extra factor is not
    ! required in every spawning routine. In the death step however, we use
    ! walker_energies(1,idet), which has a factor of 1/2 included for convenience
    ! already, for conveniece elsewhere. Hence we have to multiply by an extra factor
    ! of 2 to account for the extra 1/2 in tau. dmqmc_factor is set to 1.0 when not
    ! performing a DMQMC calculation, and so can be ignored in these cases.
    real(p) :: dmqmc_factor = 1.0_p
    ! timestep
    real(p) :: tau
    ! number of Monte Carlo cycles done in previous runs (ie from restarts, etc).
    integer :: mc_cycles_done = 0
    ! Energy offset (shift) applied to the Hamiltonian.
    real(p), allocatable :: shift(:) ! (psip_list%nspaces)
    ! The shift is updated at the end of each report loop when vary_shift is true.
    ! When the replica_tricks option is used, the elements
    ! of the shift array refer to the shifts in the corresponding replica systems.
    ! When replica_tricks is not being used, only the first element is used.
    logical, allocatable :: vary_shift(:) ! (psip_list%nspaces)
    ! Number of particles above which varyshift is turned on.
    real(p) :: target_particles = huge(1.0_p)
    ! Factor by which the changes in the population are damped when updating the
    ! shift.
    real(p) :: shift_damping = 0.050_p
    ! Restoring force factor in the harmonic damping population control algorithm
    ! from Yang, Pahl and Brand (J. Chem. Phys. 153, 174103 (2020)
    ! (DOI:10.1063/5.0023088)). The original population dynamics are obtained 
    ! if set equal to zero. 
    real(p) :: shift_harmonic_forcing = 0.0_p
    ! If true, the shift_harmonic_forcing term will be set equal to the square
    ! of the shift_damping value divided by 4 to obtain critical damping.   
    logical :: shift_harmonic_crit_damp = .false.
    ! Stores information used by the excitation generator
    type(excit_gen_data_t) :: excit_gen_data
    ! Value of beta which we propagate the density matrix to. Only used for DMQMC.
    real(p) :: target_beta = 1.0
    ! Information about the propagator (currently just quasi_newton)
    type(propagator_t) :: propagator
    ! Convenience handles.
    type(particle_t) :: psip_list
    type(spawned_particle_t) :: spawn_store
    type(reference_t) :: ref
    type(trial_t) :: trial
    type(restart_in_t) :: restart_in
    ! Flags for multireference CCMC calculations.
    logical :: multiref = .false., mr_read_in = .false.
    integer :: n_secondary_ref = 0, mr_n_frozen, mr_excit_lvl
    type(reference_t), allocatable :: secondary_refs(:)
    integer :: mr_acceptance_search
    character(255) :: mr_secref_file
    ! WARNING: par_info is the 'reference/master' (ie correct) version
    ! of parallel_t, in particular of proc_map_t.  However, copies of it
    ! are kept in spawn_t objects, and it is these copies which are used
    ! to determine the processor location of a particle.  It is the programmer's
    ! responsibility to ensure these are kept up to date...
    type(parallel_t) :: par_info
    ! Need additional parameter to identify the cause of calculation termination;
    ! we may want to print a different message depending upon the cause.
    logical :: reblock_done = .false.

    type(estimators_t), allocatable :: estimators(:)
    ! Internal flag to indicate status of shift damping optimisation.
    integer :: shift_damping_status = sd_no_optimisation
    ! String representing state of RNG. Should be set, used and deallocated as quickly as possible as it becomes invalid as soon as
    ! the next random number is drawn -- only present really for a convenient way of handling the RNG state during restarts.
    type(dSFMT_state_t) :: rng_state
end type qmc_state_t

! Copies of various settings that are required during annihilation.  This avoids having to pass through lots of different
! structs/flags for various settings.  Set in init_qmc.
! NOTE: the defaults here correspond to the defaults for the corresponding components of qmc_in_t, fciqmc_in_t and dmqmc_in_t.
type annihilation_flags_t
    ! Using the initiator approximation?
    logical :: initiator_approx = .false.
    ! True if allowing non-integer values for psip populations.
    logical :: real_amplitudes = .false.
    ! Calculate replicas (ie evolve two wavefunctions/density matrices at once)?
    ! Currently only implemented for DMQMC.
    logical :: replica_tricks = .false.
    ! Propagate a trial density matrix to a specific temeperature.
    logical :: ipdmqmc = .false.
    ! Trial function used (FCIQMC & Heisenberg model only).
    integer :: trial_function = single_basis
    ! Use symmetric version of dmqmc algortithm?
    logical :: symmetric = .true.
end type annihilation_flags_t

contains

    elemental subroutine zero_estimators_t(estimators)

        ! Zeros all values associated with a estimators_t derived type.

        ! In/Out:
        !   estimators: estimators_t object to be zeroed.

        type(estimators_t), intent(inout) :: estimators

        estimators%D0_population = 0.0_p
        estimators%proj_energy = 0.0_p
        estimators%D0_population_comp = cmplx(0.0, 0.0, p)
        estimators%proj_energy_comp = cmplx(0.0, 0.0, p)

    end subroutine zero_estimators_t

    subroutine qmc_in_t_json(js, qmc, terminal)

        ! Serialise a qmc_in_t object in JSON format.

        ! In/Out:
        !   js: json_out_t controlling the output unit and handling JSON internal state.  Unchanged on output.
        ! In:
        !   qmc: qmc_in_t object containing qmc input values (including any defaults set).
        !   terminal (optional): if true, this is the last entry in the enclosing JSON object.  Default: false.


        use json_out

        type(json_out_t), intent(inout) :: js
        type(qmc_in_t), intent(in) :: qmc
        logical, intent(in), optional :: terminal

        call json_object_init(js, 'qmc')
        call json_write_key(js, 'rng_seed', qmc%seed)
        call json_write_key(js, 'real_amplitudes', qmc%real_amplitudes)
        call json_write_key(js, 'real_amplitude_force_32', qmc%real_amplitude_force_32)
        call json_write_key(js, 'spawn_cutoff', qmc%spawn_cutoff)
        select case (qmc%excit_gen)
        case (excit_gen_renorm)
            call json_write_key(js, 'excit_gen', 'renorm')
        case (excit_gen_renorm_spin)
            call json_write_key(js, 'excit_gen', 'renorm_spin')
        case (excit_gen_no_renorm)
            call json_write_key(js, 'excit_gen', 'no_renorm')
        case (excit_gen_no_renorm_spin)
            call json_write_key(js, 'excit_gen', 'no_renorm_spin')
        case (excit_gen_power_pitzer)
            call json_write_key(js, 'excit_gen', 'power_pitzer')
        case (excit_gen_power_pitzer_occ)
            call json_write_key(js, 'excit_gen', 'uniform_power_pitzer')
        case (excit_gen_power_pitzer_occ_ij)
            call json_write_key(js, 'excit_gen', 'heat_bath_power_pitzer')
        case (excit_gen_power_pitzer_orderN)
            call json_write_key(js, 'excit_gen', 'heat_bath_power_pitzer_ref')
        case (excit_gen_cauchy_schwarz_occ)
            call json_write_key(js, 'excit_gen', 'uniform_cauchy_schwarz')
        case (excit_gen_cauchy_schwarz_occ_ij)
            call json_write_key(js, 'excit_gen', 'heat_bath_cauchy_schwarz')
        case (excit_gen_heat_bath)
            call json_write_key(js, 'excit_gen', 'heat_bath')
        case (excit_gen_heat_bath_uniform)
            call json_write_key(js, 'excit_gen', 'heat_bath_uniform_singles')
        case (excit_gen_heat_bath_single)
            call json_write_key(js, 'excit_gen', 'heat_bath_exact_singles')
        case default
            call json_write_key(js, 'excit_gen', qmc%excit_gen)
        end select
        call json_write_key(js, 'pattempt_update', qmc%pattempt_update)
        call json_write_key(js, 'pattempt_zero_accum_data', qmc%pattempt_zero_accum_data)
        call json_write_key(js, 'pattempt_single', qmc%pattempt_single)
        call json_write_key(js, 'pattempt_double', qmc%pattempt_double)
        call json_write_key(js, 'pattempt_parallel', qmc%pattempt_parallel)
        call json_write_key(js, 'tau', qmc%tau)
        call json_write_key(js, 'tau_search', qmc%tau_search)
        call json_write_key(js, 'vary_shift_from', qmc%vary_shift_from)
        call json_write_key(js, 'vary_shift_from_proje', qmc%vary_shift_from_proje)
        if (qmc%vary_shift_present) call json_write_key(js, 'vary_shift', qmc%vary_shift)
        call json_write_key(js, 'initial_shift', qmc%initial_shift)
        call json_write_key(js, 'shift_damping', qmc%shift_damping)
        call json_write_key(js, 'shift_harmonic_forcing', qmc%shift_harmonic_forcing)
        call json_write_key(js, 'shift_harmonic_crit_damp', qmc%shift_harmonic_crit_damp)
        call json_write_key(js, 'walker_length', qmc%walker_length)
        call json_write_key(js, 'spawned_walker_length', qmc%spawned_walker_length)
        call json_write_key(js, 'D0_population', qmc%D0_population)
        call json_write_key(js, 'target_particles', qmc%target_particles)
        call json_write_key(js, 'target_reference', qmc%target_reference)
        call json_write_key(js, 'initiator_approx', qmc%initiator_approx)
        call json_write_key(js, 'initiator_pop', qmc%initiator_pop)
        call json_write_key(js, 'ncycles', qmc%ncycles)
        call json_write_key(js, 'nreport', qmc%nreport)
        call json_write_key(js, 'power_pitzer_min_weight', qmc%power_pitzer_min_weight)
        call json_write_key(js, 'quasi_newton', qmc%quasi_newton)
        call json_write_key(js, 'quasi_newton_threshold', qmc%quasi_newton_threshold)
        call json_write_key(js, 'quasi_newton_value', qmc%quasi_newton_value)
        call json_write_key(js, 'quasi_newton_pop_control', qmc%quasi_newton_pop_control)
        call json_write_key(js, 'use_mpi_barriers', qmc%use_mpi_barriers, .true.)
        call json_object_end(js, terminal)

    end subroutine qmc_in_t_json

    subroutine fciqmc_in_t_json(js, fciqmc, terminal)

        ! Serialise a fciqmc_in_t object in JSON format.

        ! In/Out:
        !   js: json_out_t controlling the output unit and handling JSON internal state.  Unchanged on output.
        ! In:
        !   fciqmc: fciqmc_in_t object containing fciqmc input values (including any defaults set).
        !   terminal (optional): if true, this is the last entry in the enclosing JSON object.  Default: false.

        use json_out

        type(json_out_t), intent(inout) :: js
        type(fciqmc_in_t), intent(in) :: fciqmc
        logical, intent(in), optional :: terminal

        call json_object_init(js, 'fciqmc')
        call json_write_key(js, 'select_ref_det_every_nreports', fciqmc%select_ref_det_every_nreports)
        call json_write_key(js, 'init_spin_inv_D0', fciqmc%init_spin_inv_D0)
        call json_write_key(js, 'ref_det_factor', fciqmc%ref_det_factor)
        call json_write_key(js, 'non_blocking_comm', fciqmc%non_blocking_comm)
        call json_write_key(js, 'doing_load_balancing', fciqmc%doing_load_balancing)
        select case (fciqmc%trial_function)
        case (single_basis)
            call json_write_key(js, 'trial_function', 'single_basis')
        case (neel_singlet)
            call json_write_key(js, 'trial_function', 'neel_singlet')
        case default
            call json_write_key(js, 'trial_function', fciqmc%trial_function)
        end select
        select case (fciqmc%guiding_function)
        case (no_guiding)
            call json_write_key(js, 'guiding_function', 'none')
        case (neel_singlet_guiding)
            call json_write_key(js, 'guiding_function', 'neel_singlet')
        case default
            call json_write_key(js, 'guiding_function', fciqmc%guiding_function)
        end select
        call json_write_key(js, 'quadrature_initiator', fciqmc%quadrature_initiator)
        call json_write_key(js, 'replica_tricks', fciqmc%replica_tricks, .true.)
        call json_write_key(js, 'density_matrices', fciqmc%density_matrices, .true.)
        call json_write_key(js, 'density_matrix_file', fciqmc%density_matrix_file)
        call json_object_end(js, terminal)

    end subroutine fciqmc_in_t_json

    subroutine semi_stoch_in_t_json(js, semi_stoch, terminal)

        ! Serialise a semi_stoch_in_t object in JSON format.

        ! In/Out:
        !   js: json_out_t controlling the output unit and handling JSON internal state.  Unchanged on output.
        ! In:
        !   semi_stoch: semi_stoch_in_t object containing semi-stochastic input values (including any defaults set).
        !   terminal (optional): if true, this is the last entry in the enclosing JSON object.  Default: false.

        use json_out
        use reference_determinant, only: reference_t_json

        type(json_out_t), intent(inout) :: js
        type(semi_stoch_in_t), intent(in) :: semi_stoch
        logical, intent(in), optional :: terminal

        call json_object_init(js, 'semi_stoch')
        call json_write_key(js, 'start_iter', semi_stoch%start_iter)
        call json_write_key(js, 'shift_iter', semi_stoch%shift_iter)
        select case (semi_stoch%space_type)
        case (empty_determ_space)
            call json_write_key(js, 'space_type', 'none')
        case (high_pop_determ_space)
            call json_write_key(js, 'space_type', 'high')
        case (read_determ_space)
            call json_write_key(js, 'space_type', 'read')
        case (ci_determ_space)
            call json_write_key(js, 'space_type', 'ci')
        case default
            call json_write_key(js, 'space_type', semi_stoch%space_type)
        end select
        call json_write_key(js, 'target_size', semi_stoch%target_size)
        call json_write_key(js, 'write_determ_space', semi_stoch%write_determ_space)
        select case (semi_stoch%projection_mode)
        case (semi_stoch_separate_annihilation)
            call json_write_key(js, 'projection_mode', 'separate')
        case (semi_stoch_combined_annihilation)
            call json_write_key(js, 'projection_mode', 'combined')
        case default
            call json_write_key(js, 'projection_mode', semi_stoch%projection_mode)
        end select
        call json_write_key(js, 'read_id', semi_stoch%read_id)
        call json_write_key(js, 'write_id', semi_stoch%write_id)
        call reference_t_json(js, semi_stoch%ci_space, key='ci_space', terminal=.true.)
        call json_object_end(js, terminal)

    end subroutine semi_stoch_in_t_json

    subroutine ccmc_in_t_json(js, ccmc, terminal)

        ! Serialise a ccmc_in_t object in JSON format.

        ! In/Out:
        !   js: json_out_t controlling the output unit and handling JSON internal state.  Unchanged on output.
        ! In:
        !   ccmc: ccmc_in_t object containing ccmc input values (including any defaults set).
        !   terminal (optional): if true, this is the last entry in the enclosing JSON object.  Default: false.

        use json_out
        use errors, only: warning

        type(json_out_t), intent(inout) :: js
        type(ccmc_in_t), intent(in) :: ccmc
        character(23) :: string
        integer :: i
        logical, intent(in), optional :: terminal

        call json_object_init(js, 'ccmc')
        call json_write_key(js, 'move_freq', ccmc%move_freq)
        call json_write_key(js, 'cluster_multispawn_threshold', ccmc%cluster_multispawn_threshold)
        call json_write_key(js, 'full_nc', ccmc%full_nc)
        call json_write_key(js, 'linked', ccmc%linked)
        call json_write_key(js, 'vary_shift_reference', ccmc%vary_shift_reference)
        call json_write_key(js, 'density_matrices', ccmc%density_matrices)
        call json_write_key(js, 'density_matrix_file', ccmc%density_matrix_file)
        call json_write_key(js, 'even_selection', ccmc%even_selection)
        if (ccmc%multiref) then
            
            call json_write_key(js, 'mr_read_in', ccmc%mr_read_in)            
            call json_write_key(js, 'n_secondary_ref', ccmc%n_secondary_ref)
            if (ccmc%n_secondary_ref.le.20 .and. .not.ccmc%mr_read_in) then
                do i=1, size(ccmc%secondary_refs)
                    write (string, '(A13,I0)') 'secondary_ref', i
                    call reference_t_json(js, ccmc%secondary_refs(i), key = trim(string))
                end do
            elseif (ccmc%mr_read_in) then
                continue
            else
                call warning('ccmc_in_t_json','There are more than 20 secondary references, &
                &printing suppressed, consider using the mr_read_in functionality.')
            end if
            call json_write_key(js, 'mr_acceptance_search', ccmc%mr_acceptance_search)
        end if
        call json_write_key(js, 'multiref', ccmc%multiref, terminal=.true.)
        call json_object_end(js, terminal)

    end subroutine ccmc_in_t_json

    subroutine restart_in_t_json(js, restart, uuid_restart, terminal)

        ! Serialise a restart_in_t object in JSON format.

        ! In/Out:
        !   js: json_out_t controlling the output unit and handling JSON internal state.  Unchanged on output.
        ! In:
        !   restart: restart_in_t object containing restart input values (including any defaults set).
        !   uuid_restart: the UUID of the calculation that generated the restart file, if one was read.
        !   terminal (optional): if true, this is the last entry in the enclosing JSON object.  Default: false.

        use json_out

        type(json_out_t), intent(inout) :: js
        type(restart_in_t), intent(in) :: restart
        character(36), intent(in) :: uuid_restart
        logical, intent(in), optional :: terminal

        call json_object_init(js, 'restart')
        call json_write_key(js, 'read_restart', restart%read_restart)
        call json_write_key(js, 'read_id', restart%read_id)
        call json_write_key(js, 'write_restart', restart%write_restart)
        call json_write_key(js, 'write_id', restart%write_id)
        call json_write_key(js, 'write_freq', restart%write_freq)
        call json_write_key(js, 'write_restart_shift', restart%write_restart_shift)
        call json_write_key(js, 'write_shift_id', restart%write_shift_id)
        call json_write_key(js, 'restart_rng', restart%restart_rng, .not.restart%read_restart)
        if (restart%read_restart) call json_write_key(js, 'uuid_restart', uuid_restart, .true.)
        call json_object_end(js, terminal)

    end subroutine restart_in_t_json

    subroutine blocking_in_t_json(js, blocking, terminal)

        ! Serialise a blocking_in_t object in JSON format.

        ! In/Out:
        !   js: json_out_t controlling the output unit and handling JSON internal
        !   state. Unchanged on output.
        ! In:
        !   blocking: blocking_in_t object containing blocking input values
        !   (including any defaults set).
        !   terminal (optional): if true, this is the last entry in the
        !   enclosing JSON object. Default: false.
        use json_out

        type(json_out_t), intent(inout) :: js
        type(blocking_in_t), intent(in) :: blocking
        logical, intent(in), optional :: terminal

        call json_object_init(js, 'blocking')
        call json_write_key(js, 'blocking_on_the_fly', blocking%blocking_on_the_fly)
        call json_write_key(js, 'start_save_frequency', blocking%start_save_frequency)
        call json_write_key(js, 'start_point_number', blocking%start_point_number)
        call json_write_key(js, 'filename', blocking%filename)
        call json_write_key(js, 'start_point', blocking%start_point)
        call json_write_key(js, 'error_limit', blocking%error_limit)
        call json_write_key(js, 'blocks_used', blocking%blocks_used)
        call json_write_key(js, 'min_blocks_used', blocking%min_blocks_used)
        call json_write_key(js, 'auto_shift_damping', blocking%auto_shift_damping)
        call json_write_key(js, 'shift_damping_precision', blocking%shift_damping_precision)
        call json_write_key(js, 'force_shift_damping_opt', blocking%force_shift_damping_opt, .true.)
        call json_object_end(js, terminal)

    end subroutine blocking_in_t_json

    subroutine load_bal_in_t_json(js, lb, terminal)

        ! Serialise a load_bal_in_t object in JSON format.

        ! In/Out:
        !   js: json_out_t controlling the output unit and handling JSON internal state.  Unchanged on output.
        ! In:
        !   lb: load_bal_in_t object containing load balancing input values (including any defaults set).
        !   terminal (optional): if true, this is the last entry in the enclosing JSON object.  Default: false.

        use json_out

        type(json_out_t), intent(inout) :: js
        type(load_bal_in_t), intent(in) :: lb
        logical, intent(in), optional :: terminal

        call json_object_init(js, 'load balancing')
        call json_write_key(js, 'nslots', lb%nslots)
        call json_write_key(js, 'pop', lb%pop)
        call json_write_key(js, 'percent', lb%percent)
        call json_write_key(js, 'max_attempts', lb%max_attempts)
        call json_write_key(js, 'write_info', lb%write_info, .true.)
        call json_object_end(js, terminal)

    end subroutine load_bal_in_t_json

end module qmc_data
