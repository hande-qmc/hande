module spawning

! Module for procedures involved in the spawning step of the FCIQMC algorithm.

! We wish to spawn with probability
!   tau |H_ij|,
! where tau is the timestep of the simulation.
! The probability of doing something is the probability of selecting to attempt
! to do it multiplied by the probability of actually doing it, hence:
!   p_spawn = p_select tau*|H_ij|/p_gen
! and p_select = p_gen for normalised probabilities.
! p_select is included intrinsically in the algorithm, as we choose a random
! determinant, j, that is connected to the i-th determinant and attempt to spawn
! from a particle on i-th determinant onto the j-th determinant.
! Thus we compare to the probability tau*|H_ij|/p_gen in order to determine
! whether the spawning attempt is successful.

! This is just for top-level spawning routines and utility functions.  The
! actual work of generating a random excitation is done in the system-specific
! excit_gen_* modules.

! TODO: profile to discover how much time is spent obtaining the correct sign of
! a matrix element (i.e. find_permutation_* routines).  These can be avoided
! unless the spawning event is successful as we only need the correct sign of
! the matrix element if offspring are produced.

use const
implicit none

contains

!--- Spawning wrappers ---

    subroutine spawn_standard(rng, sys, qmc_state, spawn_cutoff, real_factor, cdet, parent_sign, &
                              gen_excit_ptr, weights, logging_info, nspawn, nspawn_im, connection)

        ! Attempt to spawn a new particle on a connected determinant.
        ! Only for use with non-complex systems.

        ! This is just a thin wrapper around a system-specific excitation
        ! generator and a utility function.

        ! In/Out:
        !    rng: random number generator.
        !    qmc_state: input options relating to QMC methods.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        ! In:
        !    sys: system being studied.
        !    spawn_cutoff: The size of the minimum spawning event allowed, in
        !        the encoded representation. Events smaller than this will be
        !        stochastically rounded up to this value or down to zero.
        !    real_factor: The factor by which populations are multiplied to
        !        enable non-integer populations.
        !    parent_sign: sign of the population on the parent determinant (i.e.
        !        either a positive or negative integer).
        !    gen_excit_ptr: procedure pointer to excitation generators.
        !        gen_excit_ptr%full *must* be set to a procedure which generates
        !        a complete excitation.
        !    weights: importance sampling weights.
        ! Out:
        !    nspawn: number of particles spawned, in the encoded representation.
        !        0 indicates the spawning attempt was unsuccessful.
        !    nspawn_im: unused argument for compatability with spawner_ptr
        !        interface for both real and complex systems. Should be set to 0
        !        if not used.
        !    connection: excitation connection between the current determinant
        !        and the child determinant, on which progeny are spawned.

        use determinant_data, only: det_info_t
        use excitations, only: excit_t
        use qmc_data, only: qmc_state_t
        use system, only: sys_t
        use proc_pointers, only: gen_excit_ptr_t
        use dSFMT_interface, only: dSFMT_t
        use hamiltonian_data
        use logging, only: write_logging_spawn, logging_t

        type(dSFMT_t), intent(inout) :: rng
        type(sys_t), intent(in) :: sys
        type(qmc_state_t), intent(inout) :: qmc_state
        integer(int_p), intent(in) :: spawn_cutoff
        integer(int_p), intent(in) :: real_factor
        type(det_info_t), intent(inout) :: cdet
        integer(int_p), intent(in) :: parent_sign
        type(gen_excit_ptr_t), intent(in) :: gen_excit_ptr
        real(p), allocatable, intent(in) :: weights(:)
        type(logging_t), intent(in) :: logging_info
        integer(int_p), intent(out) :: nspawn, nspawn_im
        type(excit_t), intent(out) :: connection

        real(p) :: pgen, qn_weight
        type(hmatel_t) :: hmatel, hmatel_tmp
        logical :: allowed

        nspawn_im = 0_int_p

        ! 1. Generate random excitation.
        call gen_excit_ptr%full(rng, sys, qmc_state%excit_gen_data, cdet, pgen, connection, hmatel, allowed)

        if (allowed) then
            qn_weight = calc_qn_spawned_weighting(sys, qmc_state%propagator, cdet%fock_sum, connection)
            hmatel_tmp = hmatel
            hmatel_tmp%r = hmatel%r * qn_weight
            if (qmc_state%excit_gen_data%p_single_double%vary_psingles) then
                associate(exdat=>qmc_state%excit_gen_data) 
                    call update_p_single_double_data(connection%nexcit, hmatel_tmp, pgen, exdat%pattempt_single, &
                        exdat%pattempt_double, sys%read_in%comp, exdat%p_single_double%rep_accum)
                end associate
            end if
        else
            qn_weight = 1.0_p
        end if
        ! 2. Attempt spawning.
        nspawn = attempt_to_spawn(rng, qmc_state%tau, spawn_cutoff, real_factor, hmatel%r * qn_weight, pgen, &
                                parent_sign)

        if (debug) call write_logging_spawn(logging_info, hmatel, pgen, qn_weight, [nspawn], real(parent_sign, p), .false.)

    end subroutine spawn_standard

    subroutine spawn_importance_sampling(rng, sys, qmc_state, spawn_cutoff, real_factor, cdet, parent_sign, &
                                         gen_excit_ptr, weights, logging_info, nspawn, nspawn_im, connection)

        ! Attempt to spawn a new particle on a connected determinant.

        ! This subroutine applies a transformation to the Hamiltonian to achieve
        ! importance sampling of the stochastic process.

        ! Only for use with non-complex systems.

        ! This is just a thin wrapper around a system-specific excitation
        ! generator, trial-function specific transformation routine and
        ! a utility function.

        ! In/Out:
        !    rng: random number generator.
        !    qmc_state: input options relating to QMC methods.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        ! In:
        !    sys: system being studied.
        !    spawn_cutoff: The size of the minimum spawning event allowed, in
        !        the encoded representation. Events smaller than this will be
        !        stochastically rounded up to this value or down to zero.
        !    real_factor: The factor by which populations are multiplied to
        !        enable non-integer populations.
        !    parent_sign: sign of the population on the parent determinant (i.e.
        !        either a positive or negative integer).
        !    gen_excit_ptr: procedure pointer to excitation generators.
        !        gen_excit_ptr%full *must* be set to a procedure which generates
        !        a complete excitation.
        !    weights: importance sampling weights.
        ! Out:
        !    nspawn: number of particles spawned, in the encoded representation.
        !        0 indicates the spawning attempt was unsuccessful.
        !    nspawn_im: unused argument for compatability with spawner_ptr
        !        interface for both real and complex systems. Should be set to 0
        !        if not used.
        !    connection: excitation connection between the current determinant
        !        and the child determinant, on which progeny are spawned.

        use determinant_data, only: det_info_t
        use system, only: sys_t
        use excitations, only: excit_t
        use proc_pointers, only: gen_excit_ptr_t
        use qmc_data, only: qmc_state_t
        use logging, only: logging_t
        use dSFMT_interface, only: dSFMT_t
        use hamiltonian_data

        type(dSFMT_t), intent(inout) :: rng
        type(sys_t), intent(in) :: sys
        type(qmc_state_t), intent(inout) :: qmc_state
        integer(int_p), intent(in) :: spawn_cutoff
        integer(int_p), intent(in) :: real_factor
        type(det_info_t), intent(inout) :: cdet
        integer(int_p), intent(in) :: parent_sign
        type(gen_excit_ptr_t), intent(in) :: gen_excit_ptr
        real(p), allocatable, intent(in) :: weights(:)
        integer(int_p), intent(out) :: nspawn, nspawn_im
        type(excit_t), intent(out) :: connection
        type(logging_t), intent(in) :: logging_info

        real(p) :: pgen
        type(hmatel_t) :: hmatel
        logical :: allowed

        nspawn_im = 0_int_p

        ! 1. Generate random excitation.
        call gen_excit_ptr%full(rng, sys, qmc_state%excit_gen_data, cdet, pgen, connection, hmatel, allowed)

        ! 2. Transform Hamiltonian matrix element by trial function.
        if (allowed) then
            call gen_excit_ptr%trial_fn(sys, cdet, connection, weights, hmatel%r)
            hmatel%r = hmatel%r * calc_qn_spawned_weighting(sys, qmc_state%propagator, cdet%fock_sum, connection)
            if (qmc_state%excit_gen_data%p_single_double%vary_psingles) then
                associate(exdat=>qmc_state%excit_gen_data) 
                    call update_p_single_double_data(connection%nexcit, hmatel, pgen, exdat%pattempt_single, &
                        exdat%pattempt_double, sys%read_in%comp, exdat%p_single_double%rep_accum)
                end associate
            end if
        end if

        ! 3. Attempt spawning.
        nspawn = attempt_to_spawn(rng, qmc_state%tau, spawn_cutoff, real_factor, hmatel%r, pgen, parent_sign)

    end subroutine spawn_importance_sampling

    subroutine spawn_lattice_split_gen(rng, sys, qmc_state, spawn_cutoff, real_factor, cdet, parent_sign, &
                                       gen_excit_ptr, weights, logging_info, nspawn, nspawn_im, connection)

        ! Attempt to spawn a new particle on a connected determinant.

        ! This is just a thin wrapper around a system-specific excitation
        ! generator and a utility function.

        ! This subroutine applies a transformation to the Hamiltonian to achieve
        ! importance sampling of the stochastic process.

        ! For lattice models (principally the Hubbard model; the savings for the
        ! Heisenberg model are minimal) one can make a useful optimisation, as
        ! determining |H_ij| is fast (indeed, constant if non-zero) and does not
        ! require full knowledge of the excitation.  As only a small fraction of
        ! spawning events are successful, it is faster to not do any unnecessary
        ! work and test whether the spawning event is successful before
        ! finalising the excitation.

        ! Only for use with non-complex systems.
        
        ! This does not set cdet%fock_sum (as the full excitation is not known),
        ! so cannot be used with quasi-newton.

        ! In/Out:
        !    rng: random number generator.
        !    qmc_state: input options relating to QMC methods.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        ! In:
        !    sys: system being studied.
        !    spawn_cutoff: The size of the minimum spawning event allowed, in
        !        the encoded representation. Events smaller than this will be
        !        stochastically rounded up to this value or down to zero.
        !    real_factor: The factor by which populations are multiplied to
        !        enable non-integer populations.
        !    parent_sign: sign of the population on the parent determinant (i.e.
        !        either a positive or negative integer).
        !    gen_excit_ptr: procedure pointer to excitation generators.
        !        gen_excit_ptr%init and gen_excit_ptr%finalise *must* be set to
        !        a pair of procedures which generate a complete excitation.
        !        gen_excit_ptr%init must return (at least) the connecting matrix
        !        element and gen_excit_ptr%finalise must fill in the rest of the
        !        information about the excitation.
        !    weights: importance sampling weights.
        ! Out:
        !    nspawn: number of particles spawned, in the encoded representation.
        !        0 indicates the spawning attempt was unsuccessful.
        !    nspawn_dummy: unused argument for compatability with spawner_ptr
        !        interface for both real and complex systems. Should be set to 0
        !        if not used.
        !    connection: excitation connection between the current determinant
        !        and the child determinant, on which progeny are spawned.

        use determinant_data, only: det_info_t
        use system, only: sys_t
        use excitations, only: excit_t
        use proc_pointers, only: gen_excit_ptr_t
        use stoch_utils, only: stochastic_round_spawned_particle
        use qmc_data, only: qmc_state_t
        use logging, only: logging_t
        use dSFMT_interface, only: dSFMT_t
        use hamiltonian_data

        type(dSFMT_t), intent(inout) :: rng
        type(sys_t), intent(in) :: sys
        type(qmc_state_t), intent(inout) :: qmc_state
        integer(int_p), intent(in) :: spawn_cutoff
        integer(int_p), intent(in) :: real_factor
        type(det_info_t), intent(inout) :: cdet
        integer(int_p), intent(in) :: parent_sign
        type(gen_excit_ptr_t), intent(in) :: gen_excit_ptr
        real(p), allocatable, intent(in) :: weights(:)
        type(logging_t), intent(in) :: logging_info
        integer(int_p), intent(out) :: nspawn, nspawn_im
        type(excit_t), intent(out) :: connection

        real(p) :: pgen
        type(hmatel_t) :: abs_hmatel, hmatel
        logical :: allowed

        nspawn_im = 0_int_p

        ! 1. Generate enough of a random excitation to determinant the
        ! generation probability and |H_ij|.
        call gen_excit_ptr%init(rng, sys, qmc_state%excit_gen_data, cdet, pgen, connection, abs_hmatel, allowed)

        ! 2. Attempt spawning.
        nspawn = stochastic_round_spawned_particle(spawn_cutoff, real_factor*qmc_state%tau*abs_hmatel%r/pgen, rng)

        if (nspawn /= 0_int_p) then

            ! 3. Complete excitation and find sign of connecting matrix element.
            call gen_excit_ptr%finalise(rng, sys, cdet, connection, hmatel)

            ! 4. Find sign of offspring.
            call set_child_sign(hmatel%r, parent_sign, nspawn)

        end if

    end subroutine spawn_lattice_split_gen

    subroutine spawn_lattice_split_gen_importance_sampling(rng, sys, qmc_state, spawn_cutoff, real_factor, cdet, parent_sign, &
                                                       gen_excit_ptr, weights, logging_info, nspawn, nspawn_im, connection)

        ! Attempt to spawn a new particle on a connected determinant.

        ! This is just a thin wrapper around a system-specific excitation
        ! generator and a utility function.

        ! For lattice models (principally the Hubbard model; the savings for the
        ! Heisenberg model are minimal) one can make a useful optimisation, as
        ! determining |H_ij| is fast (indeed, constant if non-zero) and does not
        ! require full knowledge of the excitation.  As only a small fraction of
        ! spawning events are successful, it is faster to not do any unnecessary
        ! work and test whether the spawning event is successful before
        ! finalising the excitation.

        ! Only for use with non-complex systems.

        ! In/Out:
        !    rng: random number generator.
        !    qmc_state: input options relating to QMC methods.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        ! In:
        !    sys: system being studied.
        !    spawn_cutoff: The size of the minimum spawning event allowed, in
        !        the encoded representation. Events smaller than this will be
        !        stochastically rounded up to this value or down to zero.
        !    real_factor: The factor by which populations are multiplied to
        !        enable non-integer populations.
        !    parent_sign: sign of the population on the parent determinant (i.e.
        !        either a positive or negative integer).
        !    gen_excit_ptr: procedure pointer to excitation generators.
        !        gen_excit_ptr%init and gen_excit_ptr%finalise *must* be set to
        !        a pair of procedures which generate a complete excitation.
        !        gen_excit_ptr%init must return (at least) the connecting matrix
        !        element and gen_excit_ptr%finalise must fill in the rest of the
        !        information about the excitation.
        !    weights: importance sampling weights.
        ! Out:
        !    nspawn: number of particles spawned, in the encoded representation.
        !        0 indicates the spawning attempt was unsuccessful.
        !    nspawn_dummy: unused argument for compatability with spawner_ptr
        !        interface for both real and complex systems. Should be set to 0
        !        if not used.
        !    connection: excitation connection between the current determinant
        !        and the child determinant, on which progeny are spawned.

        use determinant_data, only: det_info_t
        use system, only: sys_t
        use excitations, only: excit_t
        use proc_pointers, only: gen_excit_ptr_t
        use qmc_data, only: qmc_state_t
        use logging, only: logging_t
        use stoch_utils, only: stochastic_round_spawned_particle
        use dSFMT_interface, only: dSFMT_t
        use hamiltonian_data

        type(dSFMT_t), intent(inout) :: rng
        type(sys_t), intent(in) :: sys
        type(qmc_state_t), intent(inout) :: qmc_state
        integer(int_p), intent(in) :: spawn_cutoff
        integer(int_p), intent(in) :: real_factor
        type(det_info_t), intent(inout) :: cdet
        integer(int_p), intent(in) :: parent_sign
        type(gen_excit_ptr_t), intent(in) :: gen_excit_ptr
        real(p), allocatable, intent(in) :: weights(:)
        type(logging_t), intent(in) :: logging_info
        integer(int_p), intent(out) :: nspawn, nspawn_im
        type(excit_t), intent(out) :: connection

        real(p) :: pgen
        type(hmatel_t) :: tilde_hmatel, hmatel
        logical :: allowed

        nspawn_im = 0_int_p

        ! 1. Generate enough of a random excitation to determinant the
        ! generation probability and |H_ij|.
        call gen_excit_ptr%init(rng, sys, qmc_state%excit_gen_data, cdet, pgen, connection, tilde_hmatel, allowed)

        ! 2. Transform Hamiltonian matrix element by trial function.
        call gen_excit_ptr%trial_fn(sys, cdet, connection, weights, tilde_hmatel%r)

        ! 3. Attempt spawning.
        nspawn = stochastic_round_spawned_particle(spawn_cutoff, real_factor*qmc_state%tau*abs(tilde_hmatel%r)/pgen, rng)

        if (nspawn /= 0_int_p) then

            ! 4. Complete excitation and find sign of connecting matrix element.
            ! *NOTE*: this returns the original matrix element and *not* the
            ! matrix element after the trial function transformation.
            call gen_excit_ptr%finalise(rng, sys, cdet, connection, hmatel)

            ! 5. Find sign of offspring.
            ! Note that we don't care about the value of H_ij at this step, only
            ! the sign.
            call set_child_sign(tilde_hmatel%r*hmatel%r, parent_sign, nspawn)

        end if

    end subroutine spawn_lattice_split_gen_importance_sampling

    subroutine spawn_null(rng, sys, qmc_state, spawn_cutoff, real_factor, cdet, parent_sign, gen_excit_ptr, weights, &
                          logging_info, nspawn, nspawn_im, connection)

        ! This is a null spawning routine for use with operators which are
        ! diagonal in the basis and hence only have a cloning step in the
        ! Hellmann-Feynman sampling.  It does *nothing*.

        ! Can be used with complex or non-complex systems.

        ! In/Out:
        !    rng: random number generator.
        !    qmc_state: input options relating to QMC methods.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from (or not, in this case!).
        ! In:
        !    sys: system being studied.
        !    spawn_cutoff: The size of the minimum spawning event allowed, in
        !        the encoded representation. Events smaller than this will be
        !        stochastically rounded up to this value or down to zero.
        !    real_factor: The factor by which populations are multiplied to
        !        enable non-integer populations.
        !    parent_sign: sign of the population on the parent determinant (i.e.
        !        either a positive or negative integer).
        !    gen_excit_ptr: procedure pointer to excitation generators.
        !    weights: importance sampling weights.
        ! Out:
        !    nspawn: number of particles spawned, in the encoded representation.
        !        0 indicates the spawning attempt was unsuccessful.
        !    nspawn_dummy: unused argument for compatability with spawner_ptr
        !        interface for both real and complex systems. Should be set to 0
        !        if not used.
        !    connection: excitation connection between the current determinant
        !        and the child determinant, on which progeny are spawned.

        use determinant_data, only: det_info_t
        use system, only: sys_t
        use excitations, only: excit_t
        use proc_pointers, only: gen_excit_ptr_t
        use qmc_data, only: qmc_state_t
        use logging, only: logging_t
        use dSFMT_interface, only: dSFMT_t

        type(dSFMT_t), intent(inout) :: rng
        type(sys_t), intent(in) :: sys
        type(qmc_state_t), intent(inout) :: qmc_state
        integer(int_p), intent(in) :: spawn_cutoff
        integer(int_p), intent(in) :: real_factor
        type(det_info_t), intent(inout) :: cdet
        integer(int_p), intent(in) :: parent_sign
        type(gen_excit_ptr_t), intent(in) :: gen_excit_ptr
        real(p), allocatable, intent(in) :: weights(:)
        type(logging_t), intent(in) :: logging_info
        integer(int_p), intent(out) :: nspawn, nspawn_im
        type(excit_t), intent(out) :: connection

        ! Just some null operations to avoid -Wall -Werror causing errors.
        connection%nexcit = huge(0)

        ! Return nspawn = 0 as we don't want to do any spawning.
        nspawn = 0_int_p
        nspawn_im = 0_int_p

    end subroutine spawn_null

    subroutine spawn_complex(rng, sys, qmc_state, spawn_cutoff, real_factor, cdet, parent_sign, &
                              gen_excit_ptr, weights, logging_info, nspawn, nspawn_im, connection)

        ! Attempt to spawn a new particle on a connected determinant.

        ! This is just a thin wrapper around a system-specific excitation
        ! generator and a utility function.

        ! Only for use with complex systems.

        ! In/Out:
        !    rng: random number generator.
        !    qmc_state: input options relating to QMC methods.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        ! In:
        !    sys: system being studied.
        !    spawn_cutoff: The size of the minimum spawning event allowed, in
        !        the encoded representation. Events smaller than this will be
        !        stochastically rounded up to this value or down to zero.
        !    real_factor: The factor by which populations are multiplied to
        !        enable non-integer populations.
        !    parent_sign: sign of the population on the parent determinant (i.e.
        !        either a positive or negative integer).
        !    gen_excit_ptr: procedure pointer to excitation generators.
        !        Currently only included for compatibility to spawn_ptr inteface
        !        as used in real systems, as complex excitation generator isn't
        !        compatible with gen_excit_ptr interface.
        !    weights: importance sampling weights.
        ! Out:
        !    nspawn: number of particles spawned through real component of hmatel,
        !        in the encoded representation.
        !        0 indicates the spawning attempt was unsuccessful.
        !    nspawn_im: number of particles spawned through imaginary component of
        !        hmatel, in the encoded representation.
        !        0 indicates the spawning attempt was unsuccessful.
        !    connection: excitation connection between the current determinant
        !        and the child determinant, on which progeny are spawned.

        use determinant_data, only: det_info_t
        use excitations, only: excit_t, create_excited_det
        use qmc_data, only: qmc_state_t
        use system, only: sys_t, read_in
        use proc_pointers, only: gen_excit_ptr_t
        use dSFMT_interface, only: dSFMT_t

        use errors, only: stop_all
        use hamiltonian_data
        use logging, only: write_logging_spawn, logging_t

        type(dSFMT_t), intent(inout) :: rng
        type(sys_t), intent(in) :: sys
        type(qmc_state_t), intent(inout) :: qmc_state
        integer(int_p), intent(in) :: spawn_cutoff
        integer(int_p), intent(in) :: real_factor
        type(det_info_t), intent(inout) :: cdet
        integer(int_p), intent(in) :: parent_sign
        type(gen_excit_ptr_t), intent(in) :: gen_excit_ptr
        real(p), allocatable, intent(in) :: weights(:)
        type(logging_t), intent(in) :: logging_info
        integer(int_p), intent(out) :: nspawn, nspawn_im
        type(excit_t), intent(out) :: connection

        integer(i0) :: fexcit(sys%basis%tot_string_len)
        real(p) :: pgen, qn_weight
        logical :: allowed
        type(hmatel_t) :: hmatel, hmatel_tmp

        ! 1. Generate random excitation.
        call gen_excit_ptr%full(rng, sys, qmc_state%excit_gen_data, cdet, pgen, connection, hmatel, allowed)

        if (allowed) then
            qn_weight = calc_qn_spawned_weighting(sys, qmc_state%propagator, cdet%fock_sum, connection)
            ! [todo] - check this multiplication
            hmatel_tmp%c = qn_weight * hmatel%c
            if (qmc_state%excit_gen_data%p_single_double%vary_psingles) then
                associate(exdat=>qmc_state%excit_gen_data) 
                    call update_p_single_double_data(connection%nexcit, hmatel_tmp, pgen, exdat%pattempt_single, &
                        exdat%pattempt_double, sys%read_in%comp, exdat%p_single_double%rep_accum)
                end associate
            end if
        else
            qn_weight = 1.0_p
        end if

        ! 2. Attempt spawning.
        nspawn = attempt_to_spawn(rng, qmc_state%tau, spawn_cutoff, real_factor, qn_weight*real(hmatel%c, p), &
                                    pgen, parent_sign)
        nspawn_im = attempt_to_spawn(rng, qmc_state%tau, spawn_cutoff, real_factor, qn_weight*aimag(hmatel%c), &
                                    pgen, parent_sign)

        if (debug) then
            if (allowed) then
                call create_excited_det(sys%basis, cdet%f, connection, fexcit)
                call write_logging_spawn(logging_info, hmatel, pgen, qn_weight, [nspawn, nspawn_im], real(parent_sign,p), &
                    .true., pgen, cdet%f, fexcit, connection)
            else
                call write_logging_spawn(logging_info, hmatel, pgen, qn_weight, [nspawn, nspawn_im], real(parent_sign,p), &
                    .true., pgen, cdet%f)
            end if
        end if

    end subroutine spawn_complex

!--- Attempt spawning based upon random excitation ---

    subroutine set_child_sign(hmatel, parent_sign, nspawn)

        ! Set the sign of the child walkers based upon the sign of the
        ! Hamiltonian matrix element connecting the parent determinant to the
        ! child determinant.
        !
        ! In:
        !    hmatel: < D | H | D' >, the Hamiltonian matrix element between a
        !        determinant and a connected determinant.
        !    parent_sign: sign of the population on the parent determinant (i.e.
        !        either a positive or negative integer).
        ! In/Out:
        !    nspawn: On input, the unsigned population of child walkers spawned
        !    from |D> to |D'>.  On output, the *signed* population of child
        !    walkers produced by this spawning attempt.

        real(p), intent(in) :: hmatel
        integer(int_p), intent(in) :: parent_sign
        integer(int_p), intent(inout) :: nspawn

        ! If H_ij is positive, then the spawned walker is of opposite
        ! sign to the parent, otherwise the spawned walkers if of the same
        ! sign as the parent.
        if (hmatel > 0.0_p) then
            nspawn = -sign(nspawn, parent_sign)
        else
            nspawn = sign(nspawn, parent_sign)
        end if

    end subroutine set_child_sign

    function attempt_to_spawn(rng, tau, spawn_cutoff, real_factor, hmatel, pgen, parent_sign) result(nspawn)

        ! In:
        !    tau: timestep being used.
        !    spawn_cutoff: The size of the minimum spawning event allowed, in
        !        the encoded representation. Events smaller than this will be
        !        stochastically rounded up to this value or down to zero.
        !    real_factor: The factor by which populations are multiplied to
        !        enable non-integer populations.
        !    hmatel: Hamiltonian matrix element connecting a determinant and an
        !    excitation of that determinant.
        !    pgen: probability of generating the excitation.
        !    parent_sign: sign of the population on the parent determinant (i.e.
        !        either a positive or negative integer).
        ! In/Out:
        !    rng: random number generator.
        ! Returns:
        !    number of particles spawned.  0 indicates the spawning attempt was
        !    unsuccessful.

        use dSFMT_interface, only: dSFMT_t, get_rand_close_open
        use stoch_utils, only: stochastic_round_spawned_particle

        integer(int_p) :: nspawn

        real(p), intent(in) :: tau, pgen, hmatel
        integer(int_p), intent(in) :: parent_sign
        type(dSFMT_t), intent(inout) :: rng
        integer(int_p), intent(in) :: spawn_cutoff
        integer(int_p), intent(in) :: real_factor
        real(p) :: pspawn

        ! Calculate probability spawning is successful.
        pspawn = tau*abs(hmatel)/pgen

        ! 'Encode' the spawning probability by multiplying by 2^(real_bit_shift).
        ! We then stochastically round this probability either up or down to
        ! the nearest integers. This allows a resolution of 2^(-real_spawning)
        ! when we later divide this factor back out. (See comments for
        ! particle_t%pops).
        pspawn = pspawn*real_factor

        nspawn = stochastic_round_spawned_particle(spawn_cutoff, pspawn, rng)

        if (nspawn > 0) then
            ! If H_ij is positive, then the spawned walker is of opposite
            ! sign to the parent, otherwise the spawned walkers if of the same
            ! sign as the parent.
            if (hmatel > 0.0_p) then
                nspawn = -sign(nspawn, parent_sign)
            else
                nspawn = sign(nspawn, parent_sign)
            end if
        end if

    end function attempt_to_spawn

!--- Assuming spawning is successful, create new particle appropriately ---

    subroutine assign_particle_processor(particle_label, nbits, seed, shift, freq, np, particle_proc, slot_pos, proc_map, nslots)

        ! In:
        !    particle_label: bit string which describes the location/basis
        !       function/etc of the particle (ie psip or excip).
        !    nbits: length (in bits) of particle_label.  This allows us to ignore
        !       any additional padding at the end of the bit string for different
        !       sizes of i0 integers.
        !    seed: seed to pass to the hashing function.
        !    shift: value to add to the hash of the label before determining
        !       the processor to which the label is assigned.
        !    freq: frequency over which the result changes exactly once.
        !       See comments below.  Ignored if the shift is 0.  Must be smaller
        !       than 32.
        !    np: number of processors over which the particles are to be
        !       distributed.
        !    proc_map: array which maps determinants to processors.
        !    nslots: number of slots proc_map is divided into.
        ! Out:
        !    particle_proc: processor where determinant resides
        !    slot_pos: position in proc_map for this determinant

        use hashing, only: murmurhash_bit_string

        integer(i0), intent(in) :: particle_label(:)
        integer, intent(in) :: nbits, seed, shift, freq, np
        integer, intent(in) :: proc_map(0:)
        integer, intent(in) :: nslots
        integer, intent(out) :: particle_proc, slot_pos

        integer :: hash
        integer(i0) :: offset, mod_label(size(particle_label))

        ! (Extra credit for parallel calculations)
        ! Hash the label to get a (hopefully uniform) distribution across all
        ! possible particle labels and then modulo it to assign each label in
        ! a (hopefully uniform) fashion.
        hash = murmurhash_bit_string(particle_label, nbits, seed)
        if (shift == 0) then
            ! p = hash(label) % np
            slot_pos = modulo(hash, np*nslots)
            particle_proc = proc_map(slot_pos)
        else
            ! o = [ hash(label) + shift ] >> freq
            ! p = [ hash(label + o) ] % np
            ! Explanation:
            ! We wish to slowly vary the processor a label is assigned to.
            ! The shift is a fast(ish) varying value (e.g. the iteration
            ! number).
            ! [ hash(label) + shift ] >> freq changes exactly once in 2^freq
            ! consecutive values of the shift, i.e. when the freq lower bits of
            ! [ hash(label) + shift ] is greater than 2^freq.  We add this
            ! offset onto the label and rehash.  label+offset varies once every
            ! 2^freq values of the shift and hence the assigned processor
            ! changes at most once in this window.
            offset = ishft(hash+shift, -freq)
            ! Note that as freq is positive, offset must also be positive (ie at
            ! most the last 32-freq bis are set).  Hence, an exclusive or with
            ! the first element in the label and the offset yields a bit-wise
            ! identical result for DET_SIZE=32 and DET_SIZE=64 (ie integer(i0)
            ! containing 32- and 64-bits respectively).
            mod_label = particle_label
            mod_label(1) = ieor(mod_label(1), offset)
            hash = murmurhash_bit_string(mod_label, nbits, seed)
            slot_pos = modulo(hash, np*nslots)
            particle_proc = proc_map(slot_pos)
        end if

    end subroutine assign_particle_processor

    subroutine assign_particle_processor_dmqmc(particle_label, nbits, info_string_len, seed, shift, freq, np, particle_proc, &
                                               slot_pos, proc_map, nslots)

        ! Wrapper around assign_particle_processor to ensure we hash the same
        ! amount of data for tensor labels in DMQMC (which involve two labels)
        ! irrespective of DET_SIZE.

        ! The tensor label is formed by concatenating together the labels for
        ! both determinants.  We therefore need to ensure the same amount of
        ! padding exists between the two labels for DET_SIZE=32 and DET_SIZE=64.
        ! We do this by inserting an additional integer in the DET_SIZE=32 case
        ! if required.

        ! In:
        !    particle_label: bit string which describes the location/basis
        !       function/etc of the particle (ie psip or excip).
        !    nbits: length (in bits) of particle_label.  This allows us to ignore
        !       any additional padding at the end of the bit string for different
        !       sizes of i0 integers.
        !    seed: seed to pass to the hashing function.
        !    shift: value to add to the hash of the label before determining
        !       the processor to which the label is assigned.
        !    freq: frequency over which the result changes exactly once.
        !       See comments below.  Ignored if the shift is 0.  Must be smaller
        !       than 32.
        !    np: number of processors over which the particles are to be
        !       distributed.
        !    proc_map: array which maps determinants to processors.
        !    nslots: number of slots proc_map is divided into.
        ! Out:
        !    particle_proc: processor where determinant resides
        !    slot_pos: position in proc_map for this determinant

        integer(i0), intent(in) :: particle_label(:)
        integer, intent(in) :: info_string_len, nbits, seed, shift, freq, np
        integer, intent(in) :: proc_map(0:)
        integer, intent(in) :: nslots
        integer, intent(out) :: particle_proc, slot_pos

        integer(i0) :: particle_label_padded(size(particle_label)+1)
        integer :: tot_label_len, bit_label_len

        ! Strip out integers inserted between the bit strings for additional
        ! information if present.
        tot_label_len = size(particle_label)/2
        bit_label_len = tot_label_len - info_string_len
        particle_label_padded = 0_i0
        particle_label_padded(:bit_label_len) = particle_label(:bit_label_len)
        particle_label_padded(bit_label_len+1:2*bit_label_len) = particle_label(tot_label_len+1:tot_label_len+bit_label_len)

        if (i0_length == 32) then
            if (mod(bit_label_len,2) == 0) then
                call assign_particle_processor(particle_label_padded, nbits, seed, shift, freq, np, &
                                               particle_proc, slot_pos, proc_map, nslots)
            else
                particle_label_padded(bit_label_len+2:2*bit_label_len+1) = particle_label(bit_label_len+1:2*bit_label_len)
                particle_label_padded(bit_label_len+1) = 0_i0
                call assign_particle_processor(particle_label_padded, nbits+i0_length, seed, shift, freq, np, &
                                               particle_proc, slot_pos, proc_map, nslots)
            end if
        else
            call assign_particle_processor(particle_label_padded, nbits, seed, shift, freq, np, &
                                           particle_proc, slot_pos, proc_map, nslots)
        end if

    end subroutine assign_particle_processor_dmqmc

    subroutine add_spawned_particle(f_new, nspawn, particle_type, iproc_spawn, spawn)

        ! Add a new particle to a store of spawned particles.

        ! In:
        !    f_new:  determinant on which to spawn.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    particle_type: the index of particle type to be created.
        !    iproc_spawn: processor to which f_new belongs (see assign_particle_processor).
        ! In/Out:
        !    spawn: spawn_t object to which the spanwed particle will be added.

        use parallel, only: nthreads, iproc
        use spawn_data, only: spawn_t
        use omp_lib
        use utils, only: int_fmt

        integer(i0), intent(in) :: f_new(:)
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: particle_type, iproc_spawn
        type(spawn_t), intent(inout) :: spawn
        integer :: iunit
#ifndef _OPENMP
        integer, parameter :: thread_id = 0
#else
        integer :: thread_id
        thread_id = omp_get_thread_num()
#endif
        iunit = 6

        if (spawn%head(thread_id,iproc_spawn) + nthreads - spawn%head_start(nthreads-1,iproc_spawn) > spawn%block_size) then
            if (.not. spawn%error) then
                write (iunit,'(1X,"# Error: No space left in spawning array on processor",'//int_fmt(iproc,1)//',".")') iproc
                write (iunit,'(1X,"# Error: HANDE will exit at the end of this report loop.")')
                write (iunit,'(1X,"# Error: Note that spawning until the end of the report loop will be affected and&
                              & so results from this final loop may be slightly incorrect.")')
                write (iunit,&
                    '(1X,"# Error: Some reconvergence time should be allowed if continuing from a subsequent restart file.")')
            end if
            spawn%error = .true.
        else
            ! Move to the next position in the spawning array.
            spawn%head(thread_id,iproc_spawn) = spawn%head(thread_id,iproc_spawn) + nthreads

            ! Zero it as not all fields are set.
            spawn%sdata(:,spawn%head(thread_id,iproc_spawn)) = 0_int_s

            ! Set info in spawning array.
            spawn%sdata(:spawn%bit_str_len,spawn%head(thread_id,iproc_spawn)) = int(f_new, int_s)
            spawn%sdata(spawn%bit_str_len+particle_type,spawn%head(thread_id,iproc_spawn)) = int(nspawn, int_s)
        end if

    end subroutine add_spawned_particle

    subroutine add_flagged_spawned_particle(f_new, nspawn, particle_type, flag, iproc_spawn, spawn)

        ! Add a new particle to a store of spawned particles with the flag field
        ! set.

        ! In:
        !    f_new:  determinant on which to spawn.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    particle_type: the index of particle type to be created.
        !    flag: flag value of the determinant/particle to set in the spawn store.
        !    iproc_spawn: processor to which f_new belongs (see assign_particle_processor).
        ! In/Out:
        !    spawn: spawn_t object to which the spanwed particle will be added.

        use parallel, only: nthreads, iproc
        use spawn_data, only: spawn_t
        use omp_lib
        use utils, only: int_fmt

        integer(i0), intent(in) :: f_new(:)
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: particle_type, flag, iproc_spawn
        type(spawn_t), intent(inout) :: spawn
        integer :: iunit
#ifndef _OPENMP
        integer, parameter :: thread_id = 0
#else
        integer :: thread_id
        thread_id = omp_get_thread_num()
#endif
        iunit = 6

        if (spawn%head(thread_id,iproc_spawn) + nthreads - spawn%head_start(nthreads-1,iproc_spawn) > spawn%block_size) then
            if (.not. spawn%error) then
                write (iunit,'(1X,"# Error: No space left in spawning array on processor",'//int_fmt(iproc,1)//',".")') iproc
                write (iunit,'(1X,"# Error: HANDE will exit at the end of this report loop.")')
                write (iunit,'(1X,"# Error: Note that spawning until the end of the report loop will be affected and&
                              & so results from this final loop may be slightly incorrect.")')
                write (iunit,'(1X,"# Error: Some reconvergence time should be allowed if continuing from a subsequent&
                              & restart file.")')
            end if
            spawn%error = .true.
        else
            ! Move to the next position in the spawning array.
            spawn%head(thread_id,iproc_spawn) = spawn%head(thread_id,iproc_spawn) + nthreads

            ! Zero it as not all fields are set.
            spawn%sdata(:,spawn%head(thread_id,iproc_spawn)) = 0_int_s

            ! Set info in spawning array.
            spawn%sdata(:spawn%bit_str_len,spawn%head(thread_id,iproc_spawn)) = int(f_new, int_s)
            spawn%sdata(spawn%bit_str_len+particle_type,spawn%head(thread_id,iproc_spawn)) = int(nspawn, int_s)
            spawn%sdata(spawn%flag_indx,spawn%head(thread_id,iproc_spawn)) = int(flag, int_s)
        end if

    end subroutine add_flagged_spawned_particle

    subroutine add_spawned_particles(f_new, nspawn, iproc_spawn, spawn)

        ! Add a set of particles to a store of spawned particles.

        ! In:
        !    f_new: determinant on which to spawn.
        !    nspawn: the (signed) number of particles of each particle type to
        !       create on the spawned determinant.
        !    iproc_spawn: processor to which f_new belongs (see assign_particle_processor).
        ! In/Out:
        !    spawn: spawn_t object to which the spanwed particle will be added.

        use parallel, only: nthreads, iproc
        use spawn_data, only: spawn_t
        use omp_lib
        use utils, only: int_fmt

        integer(i0), intent(in) :: f_new(:)
        integer(int_p), intent(in) :: nspawn(:) ! (spawn%ntypes)
        integer, intent(in) :: iproc_spawn
        type(spawn_t), intent(inout) :: spawn
        integer :: iunit
#ifndef _OPENMP
        integer, parameter :: thread_id = 0
#else
        integer :: thread_id
        thread_id = omp_get_thread_num()
#endif
        iunit = 6

        if (spawn%head(thread_id,iproc_spawn) + nthreads - spawn%head_start(nthreads-1,iproc_spawn) > spawn%block_size) then
            if (.not. spawn%error) then
                write (iunit,'(1X,"# Error: No space left in spawning array on processor",'//int_fmt(iproc,1)//',".")') iproc
                write (iunit,'(1X,"# Error: HANDE will exit at the end of this report loop.")')
                write (iunit,'(1X,"# Error: Note that spawning until the end of the report loop will be affected and&
                              & so results from this final loop may be slightly incorrect.")')
                write (iunit,'(1X,"# Error: Some reconvergence time should be allowed if continuing from a subsequent&
                              & restart file.")')
            end if
            spawn%error = .true.
        else
            ! Move to the next position in the spawning array.
            spawn%head(thread_id,iproc_spawn) = spawn%head(thread_id,iproc_spawn) + nthreads

            ! Zero it as not all fields are set.
            spawn%sdata(:,spawn%head(thread_id,iproc_spawn)) = 0_int_s

            ! Set info in spawning array.
            spawn%sdata(:spawn%bit_str_len,spawn%head(thread_id,iproc_spawn)) = int(f_new, int_s)
            spawn%sdata(spawn%bit_str_len+1:spawn%bit_str_len+spawn%ntypes,spawn%head(thread_id,iproc_spawn)) = int(nspawn, int_s)
        end if

    end subroutine add_spawned_particles

    subroutine create_spawned_particle(basis, reference, cdet, connection, nspawn, particle_type, spawn, fexcit)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.  Ignored if fexcit is
        !        given.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    particle_type: the index of particle type to be created.
        !    fexcit (optional): bit string representation of the determinant spawned onto.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use parallel, only: nprocs

        use basis_types, only: basis_t
        use determinant_data, only: det_info_t
        use excitations, only: excit_t, create_excited_det
        use spawn_data, only: spawn_t
        use reference_determinant, only: reference_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        type(excit_t), intent(in) :: connection
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: particle_type
        integer(i0), intent(in), target, optional :: fexcit(:)
        type(spawn_t), intent(inout) :: spawn

        integer(i0), target :: f_local(basis%tot_string_len)
        integer(i0), pointer :: f_new(:)
        integer :: iproc_spawn, slot

        if (present(fexcit)) then
            f_new => fexcit
        else
            call create_excited_det(basis, cdet%f, connection, f_local)
            f_new => f_local
        end if

        call assign_particle_processor(f_new, spawn%bit_str_nbits, spawn%hash_seed, spawn%hash_shift, spawn%move_freq, nprocs, &
                                       iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

        call add_spawned_particle(f_new, nspawn, particle_type, iproc_spawn, spawn)

    end subroutine create_spawned_particle

    subroutine create_spawned_particle_initiator(basis, reference, cdet, connection, nspawn, particle_type, spawn, fexcit)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.  Ignored if fexcit is
        !        given.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    particle_type: the index of particle type to be created.
        !    fexcit (optional): bit string representation of the determinant spawned onto.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use parallel, only: nprocs

        use basis_types, only: basis_t
        use determinant_data, only: det_info_t
        use excitations, only: excit_t, create_excited_det
        use spawn_data, only: spawn_t
        use reference_determinant, only: reference_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        type(excit_t), intent(in) :: connection
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: particle_type
        integer(i0), intent(in), target, optional :: fexcit(:)
        type(spawn_t), intent(inout) :: spawn

        integer(i0), target :: f_local(basis%tot_string_len)
        integer(i0), pointer :: f_new(:)
        integer :: iproc_spawn, slot

        if (present(fexcit)) then
            f_new => fexcit
        else
            call create_excited_det(basis, cdet%f, connection, f_local)
            f_new => f_local
        end if

        call assign_particle_processor(f_new, spawn%bit_str_nbits, spawn%hash_seed, spawn%hash_shift, spawn%move_freq, nprocs, &
                                       iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

        call add_flagged_spawned_particle(f_new, nspawn, particle_type, cdet%initiator_flag, iproc_spawn, spawn)

    end subroutine create_spawned_particle_initiator

    subroutine create_spawned_particle_truncated(basis, reference, cdet, connection, nspawn, particle_type, spawn, fexcit)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant that excitation level is calculated from.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.  Ignored if fexcit is
        !        given.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    particle_type: the index of particle type to be created.
        !    fexcit (optional): bit string representation of the determinant spawned onto.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use parallel, only: nprocs

        use basis_types, only: basis_t
        use determinant_data, only: det_info_t
        use excitations, only: excit_t, create_excited_det, get_excitation_level, det_string
        use spawn_data, only: spawn_t
        use reference_determinant, only: reference_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        type(excit_t), intent(in) :: connection
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: particle_type
        integer(i0), intent(in), target, optional :: fexcit(:)
        type(spawn_t), intent(inout) :: spawn

        integer(i0), target :: f_local(basis%tot_string_len)
        integer(i0), pointer :: f_new(:)
        integer :: iproc_spawn, slot, max_ex_level
                                 
        if (present(fexcit)) then
            f_new => fexcit
        else
            call create_excited_det(basis, cdet%f, connection, f_local)
            f_new => f_local
        end if
        
        if (reference%max_ex_level == -1) then
            max_ex_level=reference%ex_level
        else
            max_ex_level=reference%max_ex_level
        end if

        ! Only accept spawning if it's within the truncation level.
        if (get_excitation_level(det_string(reference%hs_f0, basis), &
                                det_string(f_new,basis)) <= max_ex_level) then

            call assign_particle_processor(f_new, spawn%bit_str_nbits, spawn%hash_seed, spawn%hash_shift, spawn%move_freq, &
                                                          nprocs, iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

            call add_spawned_particle(f_new, nspawn, particle_type, iproc_spawn, spawn)

        end if
 

    end subroutine create_spawned_particle_truncated

    subroutine create_spawned_particle_initiator_truncated(basis, reference, cdet, connection, nspawn, particle_type, &
                                                           spawn, fexcit)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.  Ignored if fexcit is
        !        given.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    particle_type: the index of particle type to be created.
        !    fexcit (optional): bit string representation of the determinant spawned onto.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use parallel, only: nprocs

        use basis_types, only: basis_t
        use determinant_data, only: det_info_t
        use excitations, only: excit_t, create_excited_det, get_excitation_level, det_string
        use spawn_data, only: spawn_t
        use reference_determinant, only: reference_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        type(excit_t), intent(in) :: connection
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: particle_type
        integer(i0), intent(in), target, optional :: fexcit(:)
        type(spawn_t), intent(inout) :: spawn

        integer(i0), target :: f_local(basis%tot_string_len)
        integer(i0), pointer :: f_new(:)
        integer :: iproc_spawn, slot, max_ex_level

        if (present(fexcit)) then
            f_new => fexcit
        else
            call create_excited_det(basis, cdet%f, connection, f_local)
            f_new => f_local
        end if

        if (reference%max_ex_level == -1) then
            max_ex_level=reference%ex_level
        else
            max_ex_level=reference%max_ex_level
        end if


        ! Only accept spawning if it's within the truncation level.
        if (get_excitation_level(det_string(reference%hs_f0, basis), &
                                det_string(f_new,basis)) <= max_ex_level) then

              call assign_particle_processor(f_new, spawn%bit_str_nbits, spawn%hash_seed, spawn%hash_shift, spawn%move_freq, &
                                                          nprocs, iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

              call add_flagged_spawned_particle(f_new, nspawn, particle_type, cdet%initiator_flag, iproc_spawn, spawn)

        end if

    end subroutine create_spawned_particle_initiator_truncated

    subroutine create_spawned_particle_ras(basis, reference, cdet, connection, nspawn, particle_type, spawn, fexcit)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.  Ignored if fexcit is
        !        given.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    particle_type: the index of particle type to be created.
        !    fexcit (optional): bit string representation of the determinant spawned onto.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use parallel, only: nprocs

        use basis_types, only: basis_t
        use bit_utils, only: count_set_bits
        use calc, only: ras1, ras3, ras1_min, ras3_max
        use determinant_data, only: det_info_t
        use excitations, only: excit_t, create_excited_det, get_excitation_level, in_ras
        use spawn_data, only: spawn_t
        use reference_determinant, only: reference_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        type(excit_t), intent(in) :: connection
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: particle_type
        integer(i0), intent(in), target, optional :: fexcit(:)
        type(spawn_t), intent(inout) :: spawn

        integer(i0), target :: f_local(basis%tot_string_len)
        integer(i0), pointer :: f_new(:)
        integer :: iproc_spawn, slot

        if (present(fexcit)) then
            f_new => fexcit
        else
            call create_excited_det(basis, cdet%f, connection, f_local)
            f_new => f_local
        end if

        ! Only accept spawning if it's within the RAS space.
        if (in_ras(ras1, ras3, ras1_min, ras3_max, f_new)) then

            call assign_particle_processor(f_new, spawn%bit_str_nbits, spawn%hash_seed, spawn%hash_shift, spawn%move_freq, nprocs, &
                                           iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

            call add_spawned_particle(f_new, nspawn, particle_type, iproc_spawn, spawn)

        end if

    end subroutine create_spawned_particle_ras

    subroutine create_spawned_particle_initiator_ras(basis, reference, cdet, connection, nspawn, particle_type, &
                                                      spawn, fexcit)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant.
        !    cdet: info on the current determinant (cdet) that we will spawn
        !        from.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.  Ignored if fexcit is
        !        given.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    particle_type: the index of particle type to be created.
        !    fexcit (optional): bit string representation of the determinant spawned onto.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use parallel, only: nprocs

        use basis_types, only: basis_t
        use bit_utils, only: count_set_bits
        use calc, only: ras1, ras3, ras1_min, ras3_max
        use determinant_data, only: det_info_t
        use excitations, only: excit_t, create_excited_det, get_excitation_level, in_ras
        use spawn_data, only: spawn_t
        use reference_determinant, only: reference_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        type(excit_t), intent(in) :: connection
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: particle_type
        integer(i0), intent(in), target, optional :: fexcit(:)
        type(spawn_t), intent(inout) :: spawn

        integer(i0), target :: f_local(basis%tot_string_len)
        integer(i0), pointer :: f_new(:)
        integer :: iproc_spawn, slot

        if (present(fexcit)) then
            f_new => fexcit
        else
            call create_excited_det(basis, cdet%f, connection, f_local)
            f_new => f_local
        end if

        ! Only accept spawning if it's within the RAS space.
        if (in_ras(ras1, ras3, ras1_min, ras3_max, f_new)) then

            call assign_particle_processor_dmqmc(f_new, spawn%bit_str_nbits, basis%info_string_len, spawn%hash_seed, &
                                                 spawn%hash_shift, spawn%move_freq, &
                                                 nprocs, iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

            call add_flagged_spawned_particle(f_new, nspawn, particle_type, cdet%initiator_flag, iproc_spawn, spawn)

        end if

    end subroutine create_spawned_particle_initiator_ras

    subroutine create_spawned_particle_density_matrix(basis, reference, cdet, connection, nspawn, &
                                                      spawning_end, particle_type, spawn)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant defining the
        !         accessible region of the Hilbert space.
        !    cdet: det_info_t object containing bit string representations of
        !        determinants which we are spawning from and to.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    spawning_end: Specifies which 'end' we are spawning from
        !        currently, ie, if the elements of the density matrix are
        !        \rho_{i,j}, are we spawning from the i end, 1, or the j end, 2.
        !    particle_type: the index of particle type to be created.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use basis_types, only: basis_t
        use excitations, only: excit_t, create_excited_det
        use parallel, only: nprocs
        use reference_determinant, only: reference_t
        use determinant_data, only: det_info_t
        use spawn_data, only: spawn_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: spawning_end
        integer, intent(in) :: particle_type
        type(spawn_t), intent(inout) :: spawn
        type(excit_t), intent(in) :: connection

        integer(i0) :: f_new(basis%tot_string_len)
        integer(i0) :: f_new_tot(basis%tensor_label_len)

        ! DMQMC is not yet OpenMP parallelised.
        !integer, parameter :: thread_id = 0

        integer :: iproc_spawn, slot

        ! Create bit string of new determinant. The entire two-ended
        ! bitstring is eventually stored in f_new_tot.
        call create_excited_det(basis, cdet%f, connection, f_new)

        f_new_tot = 0_i0
        if (spawning_end==1) then
            f_new_tot(:basis%tot_string_len) = f_new
            f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = cdet%f2
        else
            f_new_tot(:basis%tot_string_len) = cdet%f2
            f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = f_new
        end if

        call assign_particle_processor_dmqmc(f_new_tot, spawn%bit_str_nbits, basis%info_string_len, spawn%hash_seed, &
                                             spawn%hash_shift, spawn%move_freq, &
                                             nprocs, iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

        call add_spawned_particle(f_new_tot, nspawn, particle_type, iproc_spawn, spawn)

    end subroutine create_spawned_particle_density_matrix

    subroutine create_spawned_particle_density_matrix_initiator(basis, reference, cdet, connection, nspawn, &
                                                                spawning_end, particle_type, spawn)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant defining the
        !         accessible region of the Hilbert space.
        !    cdet: det_info_t object containing bit string representations of
        !        determinants which we are spawning from and to.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    spawning_end: Specifies which 'end' we are spawning from
        !        currently, ie, if the elements of the density matrix are
        !        \rho_{i,j}, are we spawning from the i end, 1, or the j end, 2.
        !    particle_type: the index of particle type to be created.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use basis_types, only: basis_t
        use errors, only: stop_all
        use excitations, only: excit_t, create_excited_det
        use parallel, only: nprocs
        use reference_determinant, only: reference_t
        use determinant_data, only: det_info_t
        use spawn_data, only: spawn_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: spawning_end
        integer, intent(in) :: particle_type
        type(spawn_t), intent(inout) :: spawn
        type(excit_t), intent(in) :: connection

        integer(i0) :: f_new(basis%tot_string_len)
        integer(i0) :: f_new_tot(basis%tensor_label_len)

        ! DMQMC is not yet OpenMP parallelised.
        !integer, parameter :: thread_id = 0

        integer :: iproc_spawn, slot

        ! Create bit string of new determinant. The entire two-ended
        ! bitstring is eventually stored in f_new_tot.
        call create_excited_det(basis, cdet%f, connection, f_new)

        f_new_tot = 0_i0
        if (spawning_end==1) then
            f_new_tot(:basis%tot_string_len) = f_new
            f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = cdet%f2
        else
            f_new_tot(:basis%tot_string_len) = cdet%f2
            f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = f_new
        end if


        call assign_particle_processor_dmqmc(f_new_tot, spawn%bit_str_nbits, basis%info_string_len, spawn%hash_seed, &
                                             spawn%hash_shift, spawn%move_freq, &
                                             nprocs, iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

        call add_flagged_spawned_particle(f_new_tot, nspawn, particle_type, cdet%initiator_flag, iproc_spawn, spawn)

    end subroutine create_spawned_particle_density_matrix_initiator

    subroutine create_spawned_particle_half_density_matrix(basis, reference, cdet, connection, nspawn, &
                                                           spawning_end, particle_type, spawn)

        ! Create a spawned walker in the spawned walkers lists.
        ! If walker tries to spawn in the lower triangle of density matrix
        ! then reflect it to upper triangle by swapping bit strings for the
        ! two ends. The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant defining the
        !         accessible region of the Hilbert space.
        !    cdet: det_info_t object containing bit string representations of
        !        determinants which we are spawning from and to.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    spawning_end: Specifies which 'end' we are spawning from
        !        currently, ie, if the elements of the density matrix are
        !        \rho_{i,j}, are we spawning from the i end, 1, or the j end, 2.
        !    particle_type: the index of particle type to be created.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use bit_utils, only: bit_str_cmp
        use basis_types, only: basis_t
        use excitations, only: excit_t, create_excited_det
        use determinant_data, only: det_info_t
        use parallel, only: nprocs
        use reference_determinant, only: reference_t
        use spawn_data, only: spawn_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: spawning_end
        integer, intent(in) :: particle_type
        type(spawn_t), intent(inout) :: spawn
        type(excit_t), intent(in) :: connection

        integer(i0) :: f_new(basis%tot_string_len)
        integer(i0) :: f_new_tot(basis%tensor_label_len)

        ! DMQMC is not yet OpenMP parallelised.
        !integer, parameter :: thread_id = 0

        integer :: iproc_spawn, slot

        ! Create bit string of new determinant. The entire two-ended
        ! bitstring is eventually stored in f_new_tot.
        call create_excited_det(basis, cdet%f, connection, f_new)
        f_new_tot = 0_i0

        ! Test to see whether the new determinant resides in the upper
        ! triangle of the density matrix. If so keep bit string ends
        ! as they are. If not then swap bitstring ends so that the
        ! new psips are reflected into the upper triangle of the density
        ! matrix as they try to spawn.
        if (bit_str_cmp(f_new, cdet%f2) == -1) then
            f_new_tot(:basis%tot_string_len) = f_new
            f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = cdet%f2
        else
            f_new_tot(:basis%tot_string_len) = cdet%f2
            f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = f_new
        end if

        call assign_particle_processor_dmqmc(f_new_tot, spawn%bit_str_nbits, basis%info_string_len, spawn%hash_seed, &
                                             spawn%hash_shift, spawn%move_freq, &
                                             nprocs, iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

        call add_spawned_particle(f_new_tot, nspawn, particle_type, iproc_spawn, spawn)

    end subroutine create_spawned_particle_half_density_matrix

    subroutine create_spawned_particle_half_density_matrix_initiator(basis, reference, cdet, connection, nspawn, &
                                                           spawning_end, particle_type, spawn)

        ! Create a spawned walker in the spawned walkers lists.
        ! If walker tries to spawn in the lower triangle of density matrix
        ! then reflect it to upper triangle by swapping bit strings for the
        ! two ends. The current position in the spawning array is updated.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant defining the
        !         accessible region of the Hilbert space.
        !    cdet: det_info_t object containing bit string representations of
        !        determinants which we are spawning from and to.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    spawning_end: Specifies which 'end' we are spawning from
        !        currently, ie, if the elements of the density matrix are
        !        \rho_{i,j}, are we spawning from the i end, 1, or the j end, 2.
        !    particle_type: the index of particle type to be created.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use bit_utils, only: bit_str_cmp
        use basis_types, only: basis_t
        use excitations, only: excit_t, create_excited_det
        use determinant_data, only: det_info_t
        use parallel, only: nprocs
        use reference_determinant, only: reference_t
        use spawn_data, only: spawn_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: spawning_end
        integer, intent(in) :: particle_type
        type(spawn_t), intent(inout) :: spawn
        type(excit_t), intent(in) :: connection

        integer(i0) :: f_new(basis%tot_string_len)
        integer(i0) :: f_new_tot(basis%tensor_label_len)

        ! DMQMC is not yet OpenMP parallelised.
        !integer, parameter :: thread_id = 0

        integer :: iproc_spawn, slot

        ! Create bit string of new determinant. The entire two-ended
        ! bitstring is eventually stored in f_new_tot.
        call create_excited_det(basis, cdet%f, connection, f_new)
        f_new_tot = 0_i0

        ! Test to see whether the new determinant resides in the upper
        ! triangle of the density matrix. If so keep bit string ends
        ! as they are. If not then swap bitstring ends so that the
        ! new psips are reflected into the upper triangle of the density
        ! matrix as they try to spawn.
        if (bit_str_cmp(f_new, cdet%f2) == -1) then
            f_new_tot(:basis%tot_string_len) = f_new
            f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = cdet%f2
        else
            f_new_tot(:basis%tot_string_len) = cdet%f2
            f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = f_new
        end if

        call assign_particle_processor_dmqmc(f_new_tot, spawn%bit_str_nbits, basis%info_string_len, spawn%hash_seed, &
                                             spawn%hash_shift, spawn%move_freq, &
                                             nprocs, iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

        call add_flagged_spawned_particle(f_new_tot, nspawn, particle_type, cdet%initiator_flag, iproc_spawn, spawn)

    end subroutine create_spawned_particle_half_density_matrix_initiator

    subroutine create_spawned_particle_truncated_half_density_matrix(basis, reference, cdet, connection, nspawn, &
                                                                          spawning_end, particle_type, spawn)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! A spawned walker is only created on (f1', f2) if f1' and f2 do not differ by
        ! more than reference%ex_level basis functions, where f1' is obtained by
        ! applying the connection to f1.

        ! Note: This is the half density matrix version of create_spawned_particle_truncated_density_matrix
        ! It works in an ientical way apart from attempts to spawn on the lower triangle of the
        ! density matrix are reflected so that they are spawned on the upper triangle of the
        ! density matrix.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant defining the
        !         accessible region of the Hilbert space.
        !    cdet: det_info_t object containing bit string representations of
        !        determinants which we are spawning from and to.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    spawning_end: Specifies which 'end' we are spawning from
        !        currently, ie, if the elements of the density matrix are
        !        \rho_{i,j}, are we spawning from the i end, 1, or the j end, 2.
        !    particle_type: the index of particle type to be created.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use bit_utils, only: bit_str_cmp
        use basis_types, only: basis_t
        use excitations, only: excit_t, create_excited_det, get_excitation_level
        use determinant_data, only: det_info_t
        use parallel, only: nprocs
        use reference_determinant, only: reference_t
        use spawn_data, only: spawn_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: spawning_end
        integer, intent(in) :: particle_type
        type(spawn_t), intent(inout) :: spawn
        type(excit_t), intent(in) :: connection

        integer(i0) :: f_new(basis%tot_string_len)
        integer(i0) :: f_new_tot(basis%tensor_label_len)

        ! DMQMC is not yet OpenMP parallelised.
        !integer, parameter :: thread_id = 0

        integer :: iproc_spawn, slot

        ! Create bit string of new determinant. The entire two-ended
        ! bitstring is eventually stored in f_new_tot.
        call create_excited_det(basis, cdet%f, connection, f_new)

        if (get_excitation_level(cdet%f2, f_new) <= reference%ex_level) then

            f_new_tot = 0_i0
            ! Test to see whether the new determinant resides in the upper
            ! triangle of the density matrix. If so keep bit string ends
            ! as they are. If not then swap bitstring ends so that the
            ! new psips are reflected into the upper triangle of the density
            ! matrix as they try to spawn.
            if (bit_str_cmp(f_new, cdet%f2) == -1) then
                f_new_tot(:basis%tot_string_len) = f_new
                f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = cdet%f2
            else
                f_new_tot(:basis%tot_string_len) = cdet%f2
                f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = f_new
            end if

            call assign_particle_processor_dmqmc(f_new_tot, spawn%bit_str_nbits, basis%info_string_len, spawn%hash_seed, &
                                                 spawn%hash_shift, &
                                                 spawn%move_freq, nprocs, iproc_spawn, slot, spawn%proc_map%map, &
                                                 spawn%proc_map%nslots)

            call add_spawned_particle(f_new_tot, nspawn, particle_type, iproc_spawn, spawn)

        end if

    end subroutine create_spawned_particle_truncated_half_density_matrix

    subroutine create_spawned_particle_truncated_density_matrix(basis, reference, cdet, connection, &
                                                                nspawn, spawning_end, particle_type, spawn)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! A spawned walker is only created on (f1', f2) if f1' and f2 do not
        ! differ by more than reference%ex_level basis functions, where f1' is
        ! obtained by applying the connection to f1.

        ! In:
        !    basis: information about the single-particle basis.
        !    reference: current reference determinant defining the
        !         accessible region of the Hilbert space.
        !    cdet: det_info_t object containing bit string representations of
        !        determinants which we are spawning from and to.
        !    connection: excitation connecting the current determinant to its
        !        offspring.  Note that the perm field is not used.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    spawning_end: Specifies which 'end' we are spawning from
        !        currently, ie, if the elements of the density matrix are
        !        \rho_{i,j}, are we spawning from the i end, 1, or the j end, 2.
        !    particle_type: the index of particle type to be created.
        ! In/Out:
        !    spawn: spawn_t object to which the spawned particle will be added.

        use basis_types, only: basis_t
        use excitations, only: excit_t, create_excited_det, get_excitation_level
        use determinant_data, only: det_info_t
        use parallel, only: nprocs
        use reference_determinant, only: reference_t
        use spawn_data, only: spawn_t

        type(basis_t), intent(in) :: basis
        type(reference_t), intent(in) :: reference
        type(det_info_t), intent(in) :: cdet
        integer(int_p), intent(in) :: nspawn
        integer, intent(in) :: spawning_end
        integer, intent(in) :: particle_type
        type(spawn_t), intent(inout) :: spawn
        type(excit_t), intent(in) :: connection

        integer(i0) :: f_new(basis%tot_string_len)
        integer(i0) :: f_new_tot(basis%tensor_label_len)

        ! DMQMC is not yet OpenMP parallelised.
        !integer, parameter :: thread_id = 0

        integer :: iproc_spawn, slot

        ! Create bit string of new determinant. The entire two-ended
        ! bitstring is eventually stored in f_new_tot.
        call create_excited_det(basis, cdet%f, connection, f_new)

        if (get_excitation_level(cdet%f2, f_new) <= reference%ex_level) then

            f_new_tot = 0_i0
            if (spawning_end==1) then
                f_new_tot(:basis%tot_string_len) = f_new
                f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = cdet%f2
            else
                f_new_tot(:basis%tot_string_len) = cdet%f2
                f_new_tot((basis%tot_string_len+1):(basis%tensor_label_len)) = f_new
            end if

            call assign_particle_processor_dmqmc(f_new_tot, spawn%bit_str_nbits, basis%info_string_len, spawn%hash_seed, &
                                                 spawn%hash_shift, &
                                                 spawn%move_freq, nprocs, iproc_spawn, slot, spawn%proc_map%map, &
                                                 spawn%proc_map%nslots)

            call add_spawned_particle(f_new_tot, nspawn, particle_type, iproc_spawn, spawn)

        end if

    end subroutine create_spawned_particle_truncated_density_matrix

    subroutine create_spawned_particle_rdm(f1, f2, nspawn_in, particle_type, rdm_spawn)

        ! Create a spawned walker in the spawned walkers lists.
        ! The current position in the spawning array is updated.

        ! In:
        !    f1: the first bitstring label, representing the first density
        !        matrix index.
        !    f2: the second bitstring label, representing the second density
        !        matrix index.
        !    nspawn: the (signed) number of particles to create on the
        !        spawned determinant.
        !    particle_type: the index of particle type to be created.
        ! In/Out:
        !    rdm_spawn: rdm_spawn_t object to which the spanwed particle
        !        will be added.

        use bit_utils, only: operator(.bitstrgt.)
        use dmqmc_data, only: rdm_spawn_t
        use errors, only: stop_all
        use parallel, only: iproc, nprocs, nthreads
        use hash_table, only: hash_table_pos_t, lookup_hash_table_entry
        use hash_table, only: assign_hash_table_entry
        use utils, only: int_fmt

        integer(i0), intent(in) :: f1(:), f2(:)
        integer(int_p), intent(in) :: nspawn_in
        integer, intent(in) :: particle_type
        type(rdm_spawn_t), intent(inout) :: rdm_spawn

        integer(int_p) :: nspawn
        integer(i0) :: f_new_tot(2*size(f1))
        integer :: iproc_spawn, slot, rdm_bl
        ! WARNING!  The below algorithm is *not* suitable for conversion to
        ! thread-safety as each thread could be spawning onto the same RDM
        ! element, yet the hash table requires a given element to exist in one
        ! (and only one) location, which is not compatible with how the threaded
        ! spawning arrays work.
        integer, parameter :: thread_id = 0

        type(hash_table_pos_t) :: pos
        logical :: hit
        integer :: err_code, iunit

        iunit = 6

        rdm_bl = size(f1)

        associate(spawn=>rdm_spawn%spawn, ht=>rdm_spawn%ht, bsl=>rdm_spawn%spawn%bit_str_len)

            nspawn = nspawn_in
            f_new_tot = 0_i0

            ! Symmetry is enforced on the RDM in the following.
            if (f1 .bitstrgt. f2) then
                ! If below the diagonal, swap the bitstrings so that the spawning occurs above it.
                f_new_tot(:rdm_bl) = f2
                f_new_tot(rdm_bl+1:2*rdm_bl) = f1
            else
                f_new_tot(:rdm_bl) = f1
                f_new_tot(rdm_bl+1:2*rdm_bl) = f2
                if (all(f1 == f2)) then
                    ! Because off-diagonal elements have been doubled (elements above the diagonal taking
                    ! contributions from both below and above it), we must double the diagonal elements too.
                    nspawn = nspawn*2
                end if
            end if

            ! Can just hash everything as RDMs don't enter the Markov chain.
            call assign_particle_processor(f_new_tot, 2*i0_length*rdm_bl, spawn%hash_seed, spawn%hash_shift, spawn%move_freq, &
                                          nprocs, iproc_spawn, slot, spawn%proc_map%map, spawn%proc_map%nslots)

            call lookup_hash_table_entry(ht, f_new_tot, pos, hit)

            if (hit) then
                associate(indx => ht%table(pos%ientry,pos%islot))
                    ! Direct annihilation/cancellation in spawning array.
                    spawn%sdata(bsl+particle_type,indx) = spawn%sdata(bsl+particle_type,indx) + int(nspawn, int_s)
                end associate
            else
                ! Move to the next position in the spawning array.
                call assign_hash_table_entry(ht, pos%islot, pos, err_code)
                if (err_code /= 0) then
                    write(iunit,'(1X,a9,'//int_fmt(err_code,1)//')') 'err_code:', err_code
                    call stop_all('create_spawned_particle_rdm','Error in assigning hash &
                                  &table entry.')
                end if

                ! Fix hash table to point to the head of the spawn data for this thread/processor.
                spawn%head(thread_id,iproc_spawn) = spawn%head(thread_id,iproc_spawn) + nthreads

                if (spawn%head(thread_id,iproc_spawn) + nthreads - spawn%head_start(nthreads-1,iproc_spawn) > spawn%block_size) then
                    if (.not. spawn%error) then
                        write (iunit,'(1X,"# Error: No space left in RDM spawning array on processor",'&
                                                &//int_fmt(iproc,1)//',".")') iproc
                        write (iunit,'(1X,"# Error: HANDE will exit at the end of this report loop.")')
                        write (iunit,'(1X,"# Error: Note that RDM results from this final report loop will be incorrect.")')
                    end if
                    spawn%error = .true.
                end if

                if (.not. spawn%error) then
                    ht%table(pos%ientry,pos%islot) = spawn%head(thread_id,iproc_spawn)
                    associate(indx => ht%table(pos%ientry,pos%islot))
                        ! Set info in spawning array.
                        ! Zero it as not all fields are set.
                        spawn%sdata(:,indx) = 0_int_s
                        spawn%sdata(:bsl,indx) = int(f_new_tot, int_s)
                        spawn%sdata(bsl+particle_type,indx) = int(nspawn, int_s)
                    end associate
                end if
            end if

        end associate

    end subroutine create_spawned_particle_rdm

    pure function calc_qn_spawned_weighting(sys, propagator, spawner_dfock, connection) result(weight)

        ! The step in FCIQMC-like methods can be modified by a non-identity transformation
        ! to weight the particles being created to take a quasi-Newton step.
        ! This routine determines the weight to apply to the the resulting particle from this.

        ! In:
        !   sys:        sys_t object which specifies the system
        !   propagator: propagator_t object to determine if weighting is needed
        !   spawner_dfock: \sum_i (f_i - f^0_i) where f_i (f^0_i) is the Fock eigenvalue of the i-th occupied
        !       orbital in the spawner (reference) determinant.
        !   connection: the connection (excitation) from the spawner required to make the actual spawnee.
        !
        ! Returns:
        !   weight: The weighting required.

        ! At present this uses the weight is 1/(F(spawnee)-F(reference)).
        ! If the difference in Fock energy between the reference and the spawnee is less than
        ! propagator%quasi_newton_threshold then the weight 1/(propagator%quasi_newton_value) is used instead.
    
        use qmc_data, only:  propagator_t
        use system, only: sys_t
        use determinant_data, only: det_info_t
        use excitations, only: excit_t, create_excited_det, get_excitation_level

        real(p) :: weight
        type(sys_t), intent(in) :: sys
        type(propagator_t), intent(in) :: propagator
        real(p), intent(in) :: spawner_dfock
        type(excit_t), intent(in) :: connection
        real(p) :: diagel
        integer :: iel

        if (propagator%quasi_newton) then
            diagel = spawner_dfock
            associate(basis_fns=>sys%basis%basis_fns, to=>connection%to_orb, from=>connection%from_orb)
                do iel = 1, connection%nexcit
                    diagel = diagel + basis_fns(to(iel))%sp_eigv - basis_fns(from(iel))%sp_eigv
                end do
            end associate
            if (diagel < propagator%quasi_newton_threshold) diagel = propagator%quasi_newton_value
            weight = 1.0_p / diagel
        else
            weight = 1.0_p
        end if

    end function calc_qn_spawned_weighting

    pure function calc_qn_weighting(propagator, dfock) result(weight)

        ! In:
        !    propagator: propagator_t object containing Quasi-Newton parameters.
        !    dfock: difference in the Fock energy of a given determinant and the reference, i.e. \sum_i (f_i - f^0_i).
        ! Returns:
        !     Weighting for the determinant.

        ! If Quasi-Newton is disabled, the weight is unity.  Otherwise, we use a simple weight 1/dfock.  If dfock is
        ! less than quasi_newton_threshold, 1/quasi_newton_value is used instead.

        ! See also calc_qn_spawned_weighting.

        use qmc_data, only:  propagator_t

        real(p) :: weight
        type(propagator_t), intent(in) :: propagator
        real(p), intent(in) :: dfock

        if (propagator%quasi_newton) then
            if (dfock < propagator%quasi_newton_threshold) then
                weight = 1.0_p / propagator%quasi_newton_value
            else
                weight = 1.0_p / dfock
            end if
        else
            weight = 1.0_p
        end if

    end function calc_qn_weighting

    subroutine update_p_single_double_data(nexcit, hmatel, spawn_pgen, pattempt_single, pattempt_double, complx, loc_accum)
        
        ! Update h_pgen_singles_sum/h_pgen_doubles_sum (the sum of pattempt_single*hmatel/spawn_pgen
        ! for a single/double excitation), as well as excit_gen_singles/excit_gen_doubles, the number
        ! of single/double excitations.

        ! In:
        !    nexcit: the order of the excitation (1 for single, 2 for double)
        !    hmatel: hamiltonian matrix element
        !    spawn_pgen: pgen as it comes out of the excitation generator, probability of choosing
        !            a certain combination of orbitals for excitation.
        !    complx: true if populations are complex.
        !    pattempt_{single,double}: probability of a {single,double} excitation.
        ! In/Out:
        !    loc_accum: accumulates data for updating pattempt_single

        use hamiltonian_data, only: hmatel_t
        use excit_gens, only: p_single_double_coll_t

        integer, intent(in) :: nexcit
        type(hmatel_t), intent(in) :: hmatel
        real(p), intent(in) :: spawn_pgen, pattempt_single, pattempt_double
        logical, intent(in) :: complx
        type(p_single_double_coll_t), intent(inout) :: loc_accum

        real(p) :: hmatel_loc

        if (complx) then
            hmatel_loc = abs(hmatel%c)
        else
            hmatel_loc = abs(hmatel%r)
        end if

        if (nexcit == 1) then
            call update_p_single_double_data_helper(loc_accum%h_pgen_singles_sum, loc_accum%excit_gen_singles, &
                loc_accum%overflow_loc, hmatel_loc, spawn_pgen, pattempt_single)
        
        ! [todo] - should this be an else? Using else if is another check but is it necessary?
        else if (nexcit == 2) then
            call update_p_single_double_data_helper(loc_accum%h_pgen_doubles_sum, loc_accum%excit_gen_doubles, &
                loc_accum%overflow_loc, hmatel_loc, spawn_pgen, pattempt_double)
        end if
    
    end subroutine update_p_single_double_data

    subroutine update_p_single_double_data_helper(h_pgen_sd_sum, excit_gen_sd, overflow_loc, hmatel_loc, &
            spawn_pgen, pattempt_sd)
        
        ! Part of update_p_single_double_data function. Separate to avoid too much code duplication.

        ! In:
        !   hmatel_loc: either abs(hmatel%c) or abs(hmatel%r)
        !   spawn_pgen: spawn probability (includes pattempt_{single,double})
        !   pattempt_sd: pattempt_{single,double}

        ! In/Out:
        !   h_pgen_sd_sum: loc_accum%h_pgen_{singles,doubles}_sum
        !   excit_gen_sd: loc_accum%excit_gen_{singles,doubles}
        !   overflow_loc: loc_accum%overflow_loc
        
        real(p), intent(in) :: hmatel_loc, spawn_pgen, pattempt_sd
        real(p), intent(inout) :: h_pgen_sd_sum, excit_gen_sd
        logical :: overflow_loc
        
        real(p) :: excit_gen_sd_old

        h_pgen_sd_sum = h_pgen_sd_sum + ((hmatel_loc*pattempt_sd)/spawn_pgen)
        
        excit_gen_sd_old = excit_gen_sd
        excit_gen_sd = excit_gen_sd + 1.0_p
        ! If excit_gen_{singles,doubles} is sufficienctly large after a lot of cycles, the addition above may not
        ! change the value within the float, so we check for this and call it an overflow.
        if (abs(excit_gen_sd - excit_gen_sd_old) < depsilon) then
            overflow_loc = .true.
        end if

    end subroutine update_p_single_double_data_helper

    subroutine update_pattempt(excit_gen_data)
        
        ! First accumulate data from all MPI procs onto dummy variables if necessary, then update pattempt_single
        ! and pattempt_double.

        ! In/Out:
        !   excit_gen_data: Object containing pattempt_{single,double} and information for updating them.
        
        use excit_gens, only: excit_gen_data_t

        type(excit_gen_data_t), intent(inout) :: excit_gen_data

        associate(ps=>excit_gen_data%p_single_double)
#ifdef PARALLEL
            call communicate_pattempt_single_data(ps%rep_accum)
#endif
            call add_rep_accum_to_total(ps)
            
            call update_pattempt_single(ps, excit_gen_data%pattempt_single, excit_gen_data%pattempt_double)
            
            ! WARNING: Do not zero these before the "update_pattempt_single" call (the values are still needed).
            ! Zero rep_accum variables to be prepared for next report loop.
            ps%rep_accum%excit_gen_singles = 0.0_p
            ps%rep_accum%excit_gen_doubles = 0.0_p
            ps%rep_accum%h_pgen_singles_sum = 0.0_p
            ps%rep_accum%h_pgen_doubles_sum = 0.0_p
        end associate

    end subroutine update_pattempt

    subroutine communicate_pattempt_single_data(rep_accum)

        ! Data from all MPI procs is accumulated.
        ! WARNING: only call in parallel mode.

        ! In/Out:
        !   rep_accum: p_single_double_coll_t object

        use parallel
        use excit_gens, only: p_single_double_coll_t
        use qmc_data, only: qmc_state_t

        type(p_single_double_coll_t), intent(inout) :: rep_accum
       
#ifdef PARALLEL
        real(p) :: excit_gen_singles_sum, excit_gen_doubles_sum, h_pgen_singles_sum_sum, h_pgen_doubles_sum_sum
        integer :: ierr
        logical :: overflow_loc
        
        excit_gen_singles_sum = 0.0_p
        excit_gen_doubles_sum = 0.0_p
        h_pgen_singles_sum_sum = 0.0_p
        h_pgen_doubles_sum_sum = 0.0_p
        overflow_loc = .false.

        ! [todo] - is MPI communication best here or together with energy estimators? Do we need to disable non blocking comm?
! [review] - AJWT: It looks like this might be best done with the energy estimators, but I don't know the performance implications.  Since it's not actually critical information for the next step, it could end up being communicated between cycles in a non-blocking manner?
        call mpi_allreduce(rep_accum%excit_gen_singles, excit_gen_singles_sum, 1, mpi_preal, MPI_SUM, MPI_COMM_WORLD, ierr)
        call mpi_allreduce(rep_accum%excit_gen_doubles, excit_gen_doubles_sum, 1, mpi_preal, MPI_SUM, MPI_COMM_WORLD, ierr)
        call mpi_allreduce(rep_accum%h_pgen_singles_sum, h_pgen_singles_sum_sum, 1, mpi_preal, MPI_SUM, MPI_COMM_WORLD, ierr)
        call mpi_allreduce(rep_accum%h_pgen_doubles_sum, h_pgen_doubles_sum_sum, 1, mpi_preal, MPI_SUM, MPI_COMM_WORLD, ierr)
        ! ps%rep_accum%overflow_loc is reduced in qmc_common before this function is called.
        ! [todo] - could reduce it here.
        ! ps%counter does not need to be communicated as it increments a change done below (same calculation done on all
        ! processes.
        rep_accum%excit_gen_singles = excit_gen_singles_sum
        rep_accum%excit_gen_doubles = excit_gen_doubles_sum
        rep_accum%h_pgen_singles_sum = h_pgen_singles_sum_sum
        rep_accum%h_pgen_doubles_sum = h_pgen_doubles_sum_sum
#endif

    end subroutine communicate_pattempt_single_data

    subroutine add_rep_accum_to_total(ps)

        ! Data from the report loop gets added to total.
        
        ! In/Out:
        !   ps: p_single_double_t object with the pattempt single update data

        use excit_gens, only: p_single_double_t

        type(p_single_double_t), intent(inout) :: ps
        real(p) :: excit_gen_singles_old, excit_gen_doubles_old

        excit_gen_singles_old = ps%total%excit_gen_singles
        excit_gen_doubles_old = ps%total%excit_gen_doubles
    
        ps%total%excit_gen_singles = ps%total%excit_gen_singles + ps%rep_accum%excit_gen_singles
        ps%total%excit_gen_doubles = ps%total%excit_gen_doubles + ps%rep_accum%excit_gen_doubles
        ps%total%h_pgen_singles_sum = ps%total%h_pgen_singles_sum + ps%rep_accum%h_pgen_singles_sum
        ps%total%h_pgen_doubles_sum = ps%total%h_pgen_doubles_sum + ps%rep_accum%h_pgen_doubles_sum

        ! Check whether precision is high enough to detect change in the number of single/double excitations.
        ! If ps%total%excit_gen_singles is sufficienctly large after a lot of cycles, the addition above may not
        ! change the value within the float, so we check for this and call it an overflow.
        if ((.not. ps%rep_accum%overflow_loc) .and. (((abs(ps%total%excit_gen_singles - excit_gen_singles_old) < depsilon) .and. &
            (ps%rep_accum%excit_gen_singles > 0.0_p)) .or. &
            ((abs(ps%total%excit_gen_doubles - excit_gen_doubles_old) < depsilon) .and. &
            (ps%rep_accum%excit_gen_doubles > 0.0_p)))) then
            ps%total%overflow_loc = .true.
            ps%rep_accum%overflow_loc = .true.
        end if
    
    end subroutine add_rep_accum_to_total
        
    subroutine update_pattempt_single(ps, pattempt_single, pattempt_double)

        ! Update pattempt single using the sums of pattempt_single%hmatel/spawn_pgen for and the numbers
        ! of single and double excitations. The aim is align the means of hmatel/spawn_pgen of single
        ! and double excitations.

        ! In/Out:
        !   ps: p_single_double_t object
        ! Out:
        !   pattempt_single: probability of a single excitation
        !   pattempt_double: probability of a double excitation

        use excit_gens, only: p_single_double_t
        use parallel, only: parent

        type(p_single_double_t), intent(inout) :: ps
        real(p), intent(out) :: pattempt_single, pattempt_double
        integer :: iunit

        iunit = 6
 
        if (((ps%total%excit_gen_singles + ps%total%excit_gen_doubles) > (ps%counter*ps%every_attempts)) .and. &
            (ps%total%excit_gen_singles > (ps%counter*ps%every_min_attempts)) .and. &
            (ps%total%excit_gen_doubles > (ps%counter*ps%every_min_attempts))) then
            ps%counter = ps%counter + 1.0_p
            pattempt_single = (ps%total%h_pgen_singles_sum/ps%total%excit_gen_singles) / &
                    ((ps%total%h_pgen_doubles_sum/ps%total%excit_gen_doubles) + &
                    (ps%total%h_pgen_singles_sum/ps%total%excit_gen_singles))

            ! Make sure that pattempt_single does not get too small. Allow at least one single excitation (expected)
            ! per pattempt_single update cycle.
            if (pattempt_single < (1.0_p/ps%every_attempts)) then
                pattempt_single = 1.0_p/ps%every_attempts
                if (parent) write(iunit, '(1X, "# WARNING: min. pattempt_single!")')
            end if 

            pattempt_double = 1.0_p - pattempt_single
            
            ! Make sure that pattempt_double does not get too small. Allow at least one double excitation (expected)
            ! per pattempt_single update cycle.
            if (pattempt_double < (1.0_p/ps%every_attempts)) then
                pattempt_double = 1.0_p/ps%every_attempts
                pattempt_single = 1.0_p - pattempt_double
                if (parent) write(iunit, '(1X, "# WARNING: min. pattempt_double!")')
            end if 
            
            if (parent) write(iunit, '(1X, "# pattempt_single changed to be:",1X,es17.10)') pattempt_single
        end if

    end subroutine update_pattempt_single

end module spawning
